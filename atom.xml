<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charles&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lg666kkk.github.io/"/>
  <updated>2020-05-12T13:17:00.671Z</updated>
  <id>https://lg666kkk.github.io/</id>
  
  <author>
    <name>lg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数组去重</title>
    <link href="https://lg666kkk.github.io/2020/05/12/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://lg666kkk.github.io/2020/05/12/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-05-12T13:07:46.000Z</published>
    <updated>2020-05-12T13:17:00.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用underscore-js中的-uniq-方法"><a href="#使用underscore-js中的-uniq-方法" class="headerlink" title="使用underscore.js中的_.uniq()方法"></a>使用underscore.js中的_.uniq()方法</h2><h2 id="ES6中的Set"><a href="#ES6中的Set" class="headerlink" title="ES6中的Set"></a>ES6中的Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span> ,<span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span> ,<span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(item) === <span class="number">-1</span>) &#123;</span><br><span class="line">        result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重for循环</span></span><br><span class="line"><span class="keyword">let</span> len = arr.length</span><br><span class="line"><span class="keyword">let</span> flag;</span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES6的filter函数"><a href="#ES6的filter函数" class="headerlink" title="ES6的filter函数"></a>ES6的filter函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.includes(item) ? pre : [...pre, item]</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h2 id="转化为对象的键"><a href="#转化为对象的键" class="headerlink" title="转化为对象的键"></a>转化为对象的键</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result[item] = index</span><br><span class="line">&#125;)</span><br><span class="line">result = <span class="built_in">Object</span>.keys(result).map(<span class="function"><span class="params">item</span> =&gt;</span> ~~item)</span><br></pre></td></tr></table></figure><h2 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h2><p><strong>一旦使用排序，面试官大几率会问你排序算法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦使用排序，面试官大几率会问你排序算法</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> temp = arr.sort()</span><br><span class="line"><span class="keyword">let</span> len = temp.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用underscore-js中的-uniq-方法&quot;&gt;&lt;a href=&quot;#使用underscore-js中的-uniq-方法&quot; class=&quot;headerlink&quot; title=&quot;使用underscore.js中的_.uniq()方法&quot;&gt;&lt;/a&gt;使用undersc
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js函数</title>
    <link href="https://lg666kkk.github.io/2020/05/07/js%E5%87%BD%E6%95%B0/"/>
    <id>https://lg666kkk.github.io/2020/05/07/js%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-07T10:39:09.000Z</published>
    <updated>2020-05-07T11:06:40.988Z</updated>
    
    <content type="html"><![CDATA[<p>JS中函数主要分为声明式函数和赋值式函数</p><h2 id="声明式函数"><a href="#声明式函数" class="headerlink" title="声明式函数"></a>声明式函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名 (<span class="params"></span>) </span>&#123;</span><br><span class="line">    函数体..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于声明式函数来说，有函数的提升，并且函数名重复的话后面的会覆盖掉前面的，其实这也引出了js中的重载问题。。。这就是后话了。。(js中没有真正意义上的重载)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出两次2</span></span><br></pre></td></tr></table></figure><p>以下例子会输出什么结果呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>输出的结果应该是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// f a () &#123; console.log(6) &#125;</span></span><br><span class="line">a() <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 7</span></span><br><span class="line">a() <span class="comment">// 报错，此时的a是一个变量，这儿当做函数使用，肯定报错啊</span></span><br></pre></td></tr></table></figure><p>那么为什么会出现以上的结果呢？</p><p>首先我们要知道函数的提升和变量的提升，理论解释百度一大堆，这里用代码例子说明一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上面的例子中定义了一个变量a，一个函数a</span></span><br><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="comment">// 函数提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 这儿为啥不输出undefined，却输出函数a呢？</span></span><br><span class="line"><span class="comment">// 在js中，如果变量名与函数同名，若变量没有赋值，则函数生效，否则变量生效</span></span><br><span class="line"></span><br><span class="line">a() <span class="comment">// 这儿输出6大家都明白，就不用解释了</span></span><br><span class="line"><span class="comment">// .....后面的代码很简单，就不说了</span></span><br></pre></td></tr></table></figure><p>对于声明式函数，还有一个很有意思的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    fn()</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个代码在不同浏览器中得到的结果不一样</span></span><br><span class="line"><span class="comment">1. IE6~7 =&gt; 输出2</span></span><br><span class="line"><span class="comment">2. 低版本的火狐 =&gt; 输出1</span></span><br><span class="line"><span class="comment">3. 其他浏览器 =&gt; 报错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="赋值式函数"><a href="#赋值式函数" class="headerlink" title="赋值式函数"></a>赋值式函数</h2><p>赋值式函数也叫函数表达式</p><p>不会出现函数提升的现象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是有一个很有趣的现象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    f = n</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f); <span class="comment">// function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(f()); <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于f有如下的特征：</span></span><br><span class="line"><span class="comment">1. 只读</span></span><br><span class="line"><span class="comment">2. 只能在函数内部访问，外部无法访问</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS中函数主要分为声明式函数和赋值式函数&lt;/p&gt;
&lt;h2 id=&quot;声明式函数&quot;&gt;&lt;a href=&quot;#声明式函数&quot; class=&quot;headerlink&quot; title=&quot;声明式函数&quot;&gt;&lt;/a&gt;声明式函数&lt;/h2&gt;&lt;figure class=&quot;highlight javascri
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局和双飞翼布局</title>
    <link href="https://lg666kkk.github.io/2020/05/07/css%E8%AE%B2%E7%82%B9/"/>
    <id>https://lg666kkk.github.io/2020/05/07/css%E8%AE%B2%E7%82%B9/</id>
    <published>2020-05-07T02:07:53.000Z</published>
    <updated>2020-05-07T02:09:24.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>圣杯布局</p><p>双飞翼布局</p><p>=&gt; 左右固定，中间自适应</p></blockquote><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p><strong>浮动和负margin</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=<span class="string">'text/css'</span>&gt;</span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">      height: <span class="number">100</span>%;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &#123;</span><br><span class="line">      height: <span class="number">100</span>%;</span><br><span class="line">      padding: <span class="number">0</span> <span class="number">200</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">      width: <span class="number">200</span>px;</span><br><span class="line">      min-height: <span class="number">200</span>px;</span><br><span class="line">      background-color: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">    .center &#123;</span><br><span class="line">      width: <span class="number">100</span>%;</span><br><span class="line">      min-height: <span class="number">400</span>px;</span><br><span class="line">      background-color: lightsalmon;</span><br><span class="line">    &#125;</span><br><span class="line">    .left,</span><br><span class="line">    .center,</span><br><span class="line">    .right &#123;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: <span class="number">-100</span>%;</span><br><span class="line">      position: relative;</span><br><span class="line">      left: <span class="number">-200</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-right: <span class="number">-200</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container clearfix"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="left"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=<span class="string">'text/css'</span>&gt;</span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container,</span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container .center &#123;</span><br><span class="line">        margin: <span class="number">0</span> <span class="number">200</span>px;</span><br><span class="line">        min-height: <span class="number">400</span>px;</span><br><span class="line">        background: lightsalmon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: <span class="number">200</span>px;</span><br><span class="line">        min-height: <span class="number">200</span>px;</span><br><span class="line">        background: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">        margin-left: <span class="number">-100</span>%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">        margin-left: <span class="number">-200</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body <span class="class"><span class="keyword">class</span></span>=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="right"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他方法实现以上布局"><a href="#其他方法实现以上布局" class="headerlink" title="其他方法实现以上布局"></a>其他方法实现以上布局</h2><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>: lightsalmon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">html</span>,</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.left</span>,</span><br><span class="line">    <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">min-height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.left</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.center</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">min-height</span>: <span class="number">400px</span>;</span><br><span class="line">        <span class="attribute">background</span>: lightsalmon;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="comment">/* 兼容到IE9 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">400px</span>);</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffa07a</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;圣杯布局&lt;/p&gt;
&lt;p&gt;双飞翼布局&lt;/p&gt;
&lt;p&gt;=&amp;gt; 左右固定，中间自适应&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;圣杯布局&quot;&gt;&lt;a href=&quot;#圣杯布局&quot; class=&quot;headerlink&quot; title=&quot;圣杯布局&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS3" scheme="https://lg666kkk.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Js继承</title>
    <link href="https://lg666kkk.github.io/2020/05/05/js%E7%BB%A7%E6%89%BF/"/>
    <id>https://lg666kkk.github.io/2020/05/05/js%E7%BB%A7%E6%89%BF/</id>
    <published>2020-05-05T10:57:45.000Z</published>
    <updated>2020-05-05T11:15:01.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>面向对象是一种编程思想</p><p>JS本身是基于面向对象构建出来的，例如JS中有很多的内置类，向promise就是ES6中新增的一个内置类，我们可以基于new Promise来创建一个实例，来管理异步编程，我在项目中，promise也经常用，也研究过它的源码。。</p><p>我们平时使用的vue，jquery等也是基于面向对象的，它们都是类，可以通过创建她们的实例来操作他们</p><p>JS中的面向对象和其他编程语言略有不同，JS中的类和实例是基于原型和原型链机制来处理的，而且js中关于类的重载、继承也和其他语言不一样</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>低耦合高内聚，可复用性强</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>方法名相同，形参个数或者类型不一样 =&gt; Js中不存在真正意义上的重载</p><p> JS中的重载指的是同一个方法，根据传参不同，实现出不同的效果</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在类的继承当中，子类可以重写父类中的方法</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类继承父类中的属性和方法，目的是让子类的实例能够调用父类中的属性和方法</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>让父类的属性和方法再子类实例的原型链上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x</span><br><span class="line">    &#125;</span><br><span class="line">    A.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">    B.prototype = <span class="keyword">new</span> A(<span class="number">200</span>) <span class="comment">// B的原型指向A的实例</span></span><br><span class="line">    B.prototype.constructor = B</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    B.prototype.getY = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> b1 = <span class="keyword">new</span> B(<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(b1.y); <span class="comment">// 100</span></span><br><span class="line">    <span class="built_in">console</span>.log(b1.x); <span class="comment">// 200</span></span><br><span class="line">    b1.getY(); <span class="comment">// 100</span></span><br><span class="line">    b1.getX() <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><img src="/2020/05/05/js%E7%BB%A7%E6%89%BF/1.jpg"><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>不向其他语言一样中继承(其他语言一般是拷贝继承，也就是子类继承父类，会把父类中的属性和方法拷贝一份到子类，供子类实例调用)，他是把父类的原型放到子类实例的原型链上，实例想调取这些方法是基于__proto__原型链查找机制完成的</li><li>子类可以重写父类上的方法(这样会导致父类其他的实例也受到影响)</li></ol><img src="/2020/05/05/js%E7%BB%A7%E6%89%BF/2.jpg"><ol start="3"><li>父类中私有或者公有的属性方法，最后都会变为子类中公有的属性和方法</li></ol><h2 id="Call继承"><a href="#Call继承" class="headerlink" title="Call继承"></a>Call继承</h2><p>​    子类方法中把父类当作普通函数来执行，让父类中的this指向子类的实例，相当于给子类实例设置了很多私有属性或方法</p><ol><li>特点：<ul><li>只能继承父类私有的属性或方法(由于把父类当作来执行，和其原型上的属性和方法无关)</li><li>父类私有的变成子类私有的</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x</span><br><span class="line">    &#125;</span><br><span class="line">    A.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">      A.call(<span class="keyword">this</span>, <span class="number">200</span>) <span class="comment">// b1.x = 200</span></span><br><span class="line">      <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    B.prototype.getY = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> b1 = <span class="keyword">new</span> B()</span><br><span class="line">    <span class="built_in">console</span>.log(b1.x);</span><br></pre></td></tr></table></figure><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>Call继承 + 类似于原型继承</p><p>父类私有和公有属性方法分别是子类实例的私有和公有属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x</span><br><span class="line">    &#125;</span><br><span class="line">    A.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">      A.call(<span class="keyword">this</span>, <span class="number">200</span>) <span class="comment">// b1.x = 200</span></span><br><span class="line">      <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Object.create(obj) =&gt; 创建一个空对象，让空对象的__proto__指向obj</span></span><br><span class="line">    B.prototype = <span class="built_in">Object</span>.create(A.prototype)</span><br><span class="line">    B.prototype.constructor = B;</span><br><span class="line">    B.prototype.getY = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> b1 = <span class="keyword">new</span> B()</span><br><span class="line">    <span class="built_in">console</span>.log(b1.x);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">若不兼容Object.create方法，可以自定义一个该方法</span></span><br><span class="line"><span class="comment">Object.create = function (obj) &#123;</span></span><br><span class="line"><span class="comment">function Fn () &#123;&#125;</span></span><br><span class="line"><span class="comment">Fn.prototype = obj</span></span><br><span class="line"><span class="comment">return new Fn()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/2020/05/05/js%E7%BB%A7%E6%89%BF/3.jpg"><h2 id="ES6中的继承简单认识"><a href="#ES6中的继承简单认识" class="headerlink" title="ES6中的继承简单认识"></a>ES6中的继承简单认识</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6中的继承</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">          <span class="keyword">constructor</span> (x) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x</span><br><span class="line">          &#125;</span><br><span class="line">          getX () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =&gt; B.prototype.__proto__ = A.prototy</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">          <span class="keyword">constructor</span> (y) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">200</span>) <span class="comment">// super() =&gt; A.call(this)</span></span><br><span class="line">            <span class="keyword">this</span>.y</span><br><span class="line">          &#125;</span><br><span class="line">          getY () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> b1 = <span class="keyword">new</span> B(<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(b1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是面向对象？&quot;&gt;&lt;a href=&quot;#什么是面向对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是面向对象？&quot;&gt;&lt;/a&gt;什么是面向对象？&lt;/h2&gt;&lt;p&gt;面向对象是一种编程思想&lt;/p&gt;
&lt;p&gt;JS本身是基于面向对象构建出来的，例如JS中有很多的内
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js数据类型检测</title>
    <link href="https://lg666kkk.github.io/2020/05/03/js%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/"/>
    <id>https://lg666kkk.github.io/2020/05/03/js%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/</id>
    <published>2020-05-03T14:30:28.000Z</published>
    <updated>2020-05-03T14:31:35.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS数据类型检测的四种方法"><a href="#JS数据类型检测的四种方法" class="headerlink" title="JS数据类型检测的四种方法"></a>JS数据类型检测的四种方法</h2><ol><li>typeof</li><li>instranceof</li><li>constructor</li><li>Object.prototype.toString.call() </li></ol><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* typeof:用来检测数据类型的运算符</span></span><br><span class="line"><span class="comment">* 1. typeof [value]</span></span><br><span class="line"><span class="comment">* 2. <span class="doctag">@return </span></span></span><br><span class="line"><span class="comment">*    1) 首先是个字符串</span></span><br><span class="line"><span class="comment">*    2) 字符串中包含对应的数据类型</span></span><br><span class="line"><span class="comment">*        "number", "object", "undefined", "function", "boolean", "symbol", "bigint"</span></span><br><span class="line"><span class="comment">* 3. @局限</span></span><br><span class="line"><span class="comment">*    1) typeof null =&gt; "object"</span></span><br><span class="line"><span class="comment">*    2) 不能具体区分对象数据类型的值</span></span><br><span class="line"><span class="comment">*       typeof 数组 =&gt; "object"</span></span><br><span class="line"><span class="comment">*       typeof &#123;&#125; =&gt; "object"</span></span><br><span class="line"><span class="comment">*       typeof 正则 =&gt; "object"</span></span><br><span class="line"><span class="comment">* 4. @优势</span></span><br><span class="line"><span class="comment">*    使用方便，能快速检查undefined,string,number,boolean, function等类型 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">n, m, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 形参赋值默认值*/</span></span><br><span class="line">    <span class="comment">//   1. ES6 =&gt; function func (n=0, m=0) &#123;&#125; // 若没有传，默认为0</span></span><br><span class="line">    <span class="comment">//   2. typeof m==="undefined" ? m=0 : null</span></span><br><span class="line">    <span class="comment">//   3. n = n || 0 、 m = m || 0  =&gt; 不够严谨，若用户传一个false,则也会将其赋值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 回调函数执行 */</span></span><br><span class="line">    <span class="comment">//  1. typeof callback === "function" ? callback() : null</span></span><br><span class="line">    <span class="comment">//  2. callback &amp;&amp; callback() ==&gt; 传递的为真即执行，不一定是一个函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof-amp-amp-constructor"><a href="#instanceof-amp-amp-constructor" class="headerlink" title="instanceof &amp;&amp; constructor"></a>instanceof &amp;&amp; constructor</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * instanceof: 本意是用来检测实例是否隶属于某个类的运算符，我们基于这样的方式也可以用来做某些数据类型的检测，例如数组、正则等</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span></span></span><br><span class="line"><span class="comment">    *    true/false</span></span><br><span class="line"><span class="comment">    * @局限性</span></span><br><span class="line"><span class="comment">    *    1. 不能处理基本数据类型值</span></span><br><span class="line"><span class="comment">    *    2. 只要在当前实例的原型链(__proto__)中出现过的类检测结果都是true(可能会手动修改原型链的指向：example.__proto__或者 原型继承)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// ----------------------------------------------------</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// arguments 类数组(其原型链直接到Object,没有到Array)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">arguments</span>.__proto__ = <span class="built_in">Array</span>.prototype</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">   &#125;</span><br><span class="line">   func()</span><br><span class="line">   <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">   <span class="comment">// let s = 11</span></span><br><span class="line">   <span class="comment">// console.log(s instanceof Number); // false</span></span><br><span class="line">   <span class="comment">// let arr =[],</span></span><br><span class="line">   <span class="comment">//     reg = /^$/,</span></span><br><span class="line">   <span class="comment">//     obj = &#123;&#125;;</span></span><br><span class="line">   <span class="comment">// console.log(arr instanceof Array); // true</span></span><br><span class="line">   <span class="comment">// console.log(reg instanceof Array); // false</span></span><br><span class="line">   <span class="comment">// console.log(reg instanceof Object); // true</span></span><br><span class="line">   <span class="comment">// console.log(reg instanceof RegExp); // true</span></span><br><span class="line">   <span class="comment">// console.log(obj instanceof Array); // false</span></span><br><span class="line">   <span class="comment">// -----------------------------------------------------</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建数值的两种方式(不管那种方法创建都是Number类的实例，因为可以使用Number原型上的方法)</span></span><br><span class="line"><span class="comment">    *    1. 字面量 =&gt; let n = 12 =&gt; 不能使用instanceof检测</span></span><br><span class="line"><span class="comment">    *    2. 构造函数 =&gt; let m = new Number('13') =&gt; typeof m 的值为"object"、 m instarnceof Number为true</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * constructor: 构造函数</span></span><br><span class="line"><span class="comment">     * @原理：在类的原型上一般都会带有constructor,存储当前类本身，我们也是利用这一点，获取实例的constructor值，验证是否为所属类，从而进行数据类型检测</span></span><br><span class="line"><span class="comment">     * @局限性</span></span><br><span class="line"><span class="comment">     *      1. constructor属性太容易被修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">12</span>,</span><br><span class="line">        arr = []</span><br><span class="line">    <span class="built_in">console</span>.log(n.constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    arr.constructor = <span class="number">111</span> <span class="comment">// =&gt; 设置私有属性，每次查找会先看自己有没有，没有再去看原型有没有</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.constructor === <span class="number">111</span>); <span class="comment">// true</span></span><br><span class="line">    Func.prototype = &#123;&#125; <span class="comment">// 这样原型上就没有constructor属性了(重构了)</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call-value"><a href="#Object-prototype-toString-call-value" class="headerlink" title="Object.prototype.toString.call([value])"></a>Object.prototype.toString.call([value])</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Object.prototype.toString.call([value]):调用Object原型上的toString方法，让方法执行的时候，方法中的this是要检测的数据类型，从而获取到数据类型所属类的详细信息</span></span><br><span class="line"><span class="comment">     *  @返回信息的模板 =&gt; "[object 所属类]" 例如"[object Array]"</span></span><br><span class="line"><span class="comment">     *  在所有的数据类型类中，他们的原型上都有toString方法，除了Object.prototype.toString不是把数据值转换为字符串，其余都转换为字符串</span></span><br><span class="line"><span class="comment">     * 可以检测所有的数据类型</span></span><br><span class="line"><span class="comment">     *    "[object Undefined]" "[object BigInt]" "[object Array]" "[object Boolean]" "[object Null]" "[object String]" </span></span><br><span class="line"><span class="comment">     *    "[object Number]" "[object RegExp]" "[object Symbol]" "[object Function]" "[object Object]" "[object Date]"</span></span><br><span class="line"><span class="comment">     *    "[object Set]" "[object Math]" ....</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*let obj1 = &#123;&#125;,</span></span><br><span class="line"><span class="comment">        obj2 = &#123;</span></span><br><span class="line"><span class="comment">          name : "lg"</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// console.log([11, 12].toString()); // "11, 12"</span></span><br><span class="line">    <span class="comment">// console.log(/^\d+$/.toString()); // "/^\d+$/"</span></span><br><span class="line">    <span class="comment">// console.log((function func () &#123;&#125;).toString()); // "function func () &#123;&#125;"</span></span><br><span class="line">    <span class="comment">// console.log(obj1.toString()); // "[object Object]"</span></span><br><span class="line">    <span class="comment">// console.log(obj2.toString()); // "[object Object]"</span></span><br><span class="line">    <span class="comment">// console.log([].__proto__.__proto__.toString()); // "[object Object]"</span></span><br><span class="line">    <span class="comment">//obj1.toString() // 基于原型链机制查找，找到Object.prototype.toString，把找到的方法执行，方法中的this执行obj1,方法内部把this(obj1)的所属类信息输出</span></span><br></pre></td></tr></table></figure><h2 id="自定义数据类型检测方法"><a href="#自定义数据类型检测方法" class="headerlink" title="自定义数据类型检测方法"></a>自定义数据类型检测方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ES6</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      <span class="keyword">let</span> _obj = &#123;</span><br><span class="line">            isNumeric: <span class="string">"Number"</span>,</span><br><span class="line">            isFunction: <span class="string">"Function"</span>,</span><br><span class="line">            isString: <span class="string">"String"</span>,</span><br><span class="line">            isNull: <span class="string">"Null"</span>,</span><br><span class="line">            isUndefined: <span class="string">"Undefined"</span>,</span><br><span class="line">            isSymbol: <span class="string">"Symbol"</span>,</span><br><span class="line">            isPlainObject: <span class="string">"Object"</span>, <span class="comment">// 纯粹对象</span></span><br><span class="line">            isArray: <span class="string">"Array"</span>,</span><br><span class="line">            isRegExp: <span class="string">"RegExp"</span>,</span><br><span class="line">            isDate: <span class="string">"Date"</span>,</span><br><span class="line">            isWindow: <span class="string">"Window"</span>,</span><br><span class="line">            isBoolean: <span class="string">"Boolean"</span></span><br><span class="line">          <span class="comment">// .....</span></span><br><span class="line">          &#125;,</span><br><span class="line">          _toString = (&#123;&#125;).toString,</span><br><span class="line">          _type = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> _obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_obj.hasOwnProperty(key)) <span class="keyword">break</span> <span class="comment">// 不是私有属性，结束循环</span></span><br><span class="line">        <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[object "</span>+ _obj[key] +<span class="string">"\\]"</span>)</span><br><span class="line">        _type[key] = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> reg.test(_toString.call(value))</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(_type.isNumeric(<span class="number">12</span>)); <span class="comment">// true</span></span><br><span class="line">      <span class="built_in">console</span>.log(_type.isNumeric(<span class="string">"sss"</span>)); <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(_type.isFunction(<span class="built_in">Array</span>)); <span class="comment">// true</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ES5 =&gt; 闭包</span></span><br><span class="line"><span class="keyword">var</span> _obj = &#123;</span><br><span class="line">            isNumeric: <span class="string">"Number"</span>,</span><br><span class="line">            isFunction: <span class="string">"Function"</span>,</span><br><span class="line">            isString: <span class="string">"String"</span>,</span><br><span class="line">            isNull: <span class="string">"Null"</span>,</span><br><span class="line">            isUndefined: <span class="string">"Undefined"</span>,</span><br><span class="line">            isSymbol: <span class="string">"Symbol"</span>,</span><br><span class="line">            isPlainObject: <span class="string">"Object"</span>, <span class="comment">// 纯粹对象</span></span><br><span class="line">            isArray: <span class="string">"Array"</span>,</span><br><span class="line">            isRegExp: <span class="string">"RegExp"</span>,</span><br><span class="line">            isDate: <span class="string">"Date"</span>,</span><br><span class="line">            isWindow: <span class="string">"Window"</span>,</span><br><span class="line">            isBoolean: <span class="string">"Boolean"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          _toString = (&#123;&#125;).toString,</span><br><span class="line">          _type = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> _obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_obj.hasOwnProperty(key)) <span class="keyword">break</span> <span class="comment">// 不是私有属性，结束循环</span></span><br><span class="line">        _type[key] = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[object "</span>+ _obj[key] +<span class="string">"\\]"</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> reg.test(_toString.call(value))</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;)();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(_type.isNumeric(<span class="number">12</span>)); <span class="comment">// true</span></span><br><span class="line">      <span class="built_in">console</span>.log(_type.isNumeric(<span class="string">"sss"</span>)); <span class="comment">// false</span></span><br><span class="line">      <span class="built_in">console</span>.log(_type.isFunction(<span class="built_in">Array</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS数据类型检测的四种方法&quot;&gt;&lt;a href=&quot;#JS数据类型检测的四种方法&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型检测的四种方法&quot;&gt;&lt;/a&gt;JS数据类型检测的四种方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;typeof&lt;/li&gt;
&lt;li&gt;inst
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>with关键字</title>
    <link href="https://lg666kkk.github.io/2020/04/29/unknowjs1/"/>
    <id>https://lg666kkk.github.io/2020/04/29/unknowjs1/</id>
    <published>2020-04-29T00:47:58.000Z</published>
    <updated>2020-04-29T01:19:00.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="With"><a href="#With" class="headerlink" title="With"></a>With</h2><p>本质上是通过将一个对象的引用当做作用于来处理，将对象的属性当做作用域中的标识符来处理，从而创建一个新的词法作用域。</p><p>首先，with是JS中欺骗词法的方法之一，另一种方法是eval()</p><ol><li>with通常被当做重复引用同一对象中的多个属性的快捷方式，可以不需要重复引用对象本身</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a : <span class="number">3</span>,</span><br><span class="line">    b : <span class="number">4</span>,</span><br><span class="line">    d : <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">8</span>,</span><br><span class="line">    b = <span class="number">9</span>,</span><br><span class="line">    d = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用with就相当于直接使用obj.a=8、obj.b=9、obj.d=10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// a=8, b=9, d=10</span></span><br></pre></td></tr></table></figure><ol start="2"><li>看如下代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    a : <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">    b : <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line">foo(o1)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a); <span class="comment">// 2</span></span><br><span class="line">foo(o2)</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p><strong>为什么会出现这种情况呢？？</strong></p><p>对于o1来说，其本身就有一个a属性，使用with关键字后，可以理解为with关键字的作用域就是o1,o1本身就有一个a属性，再对其进行了LHS引用，使a的值改变，这是显而易见的</p><p>对于o2来说，其本身没有一个a属性，使用with关键字后，with关键字的作用域就变成了o2,但是o2中没有a属性，所以o2.a就被赋值为了undefined，然后使用的LHS引用，从他的上一级作用域去去查找a,直到找到全局作用域，如果还没有找到a,就会在全局创建一个a并赋值为2(当然这是在非严格模式下的情况)</p><p>所以with会在运行时修改或创建一个新的作用域，以此来欺骗其他在书写时定义的词法作用域。</p><p>在严格模式下使用with会直接报错，严格模式下with是被禁止使用的</p><ol start="3"><li>虽然with在某些方面极为方便，但是<strong>非常不推荐使用with关键字</strong><ul><li>会影响JS引擎在编译阶段的性能优化，如果代码中由大量的with，那么运行起来会非常慢</li><li>严格模式下无法使用</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;With&quot;&gt;&lt;a href=&quot;#With&quot; class=&quot;headerlink&quot; title=&quot;With&quot;&gt;&lt;/a&gt;With&lt;/h2&gt;&lt;p&gt;本质上是通过将一个对象的引用当做作用于来处理，将对象的属性当做作用域中的标识符来处理，从而创建一个新的词法作用域。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="《你所不知道的JavaScript》" scheme="https://lg666kkk.github.io/tags/%E3%80%8A%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>bind函数补充</title>
    <link href="https://lg666kkk.github.io/2020/04/28/bind1/"/>
    <id>https://lg666kkk.github.io/2020/04/28/bind1/</id>
    <published>2020-04-28T13:59:01.000Z</published>
    <updated>2020-04-28T14:14:53.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bind返回函数被当成构造函数的情况"><a href="#bind返回函数被当成构造函数的情况" class="headerlink" title="bind返回函数被当成构造函数的情况"></a>bind返回函数被当成构造函数的情况</h2><p>在MDN中有这么一句话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind()中的第一个参数：调用绑定函数时作为 <span class="keyword">this</span> 参数传递给目标函数的值。</span><br><span class="line">如果使用<span class="keyword">new</span>运算符构造绑定函数，则忽略该值</span><br></pre></td></tr></table></figure><p>那么这句话啥意思呢？？</p><p>首先，我们都知道bind()会返回一个新的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时this不再指向传入给bind的第一个参数，而是指向用new创建的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = func.bind(obj)</span><br><span class="line">newObj()</span><br><span class="line"><span class="comment">//&#123;a:1, say:f&#125; 此时this指向obj</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// func&#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = func.bind(obj)</span><br><span class="line"><span class="comment">// 若将返回的函数作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> newObj(<span class="string">'seven'</span>)</span><br><span class="line"><span class="comment">//this的指向发生了改变，指向原函数，并且可以访问原函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'o'</span>, o);</span><br><span class="line"><span class="comment">// func&#123;name:'seven'&#125;</span></span><br><span class="line">o.hello() <span class="comment">// seven</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;bind返回函数被当成构造函数的情况&quot;&gt;&lt;a href=&quot;#bind返回函数被当成构造函数的情况&quot; class=&quot;headerlink&quot; title=&quot;bind返回函数被当成构造函数的情况&quot;&gt;&lt;/a&gt;bind返回函数被当成构造函数的情况&lt;/h2&gt;&lt;p&gt;在MDN中有
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS中的bind</title>
    <link href="https://lg666kkk.github.io/2020/04/28/bind/"/>
    <id>https://lg666kkk.github.io/2020/04/28/bind/</id>
    <published>2020-04-28T08:16:21.000Z</published>
    <updated>2020-04-28T09:07:14.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是bind"><a href="#什么是bind" class="headerlink" title="什么是bind"></a>什么是bind</h2><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li>thisArg</li></ol><ul><li>调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a>运算符构造绑定函数，则忽略该值。当使用 <code>bind</code> 在 <code>setTimeout</code> 中创建一个函数（作为回调提供）时，作为 <code>thisArg</code> 传递的任何原始值都将转换为 <code>object</code>。如果 <code>bind</code> 函数的参数列表为空，执行作用域的 <code>this</code> 将被视为新函数的 <code>thisArg</code>。</li></ul><ol start="2"><li><code>arg1, arg2, ...</code></li></ol><ul><li>当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个原函数的拷贝，并拥有指定的 <strong>this</strong> 值和初始参数</p><h2 id="bind特点"><a href="#bind特点" class="headerlink" title="bind特点"></a>bind特点</h2><ol><li>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this(js的this是动态的，改变this有三种方式call,apply,bind)，之后的一序列参数将会在传递的实参前传入作为它的参数。</li><li>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被略，同时调用时的参数被提供给模拟函数。</li></ol><h2 id="mdn的Polyfill"><a href="#mdn的Polyfill" class="headerlink" title="mdn的Polyfill"></a>mdn的Polyfill</h2><p>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。</p><p>比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/text-shadow" target="_blank" rel="noopener"><code>text-shadow</code></a>，或其他任何你想要的功能</p><p>Poly表示可以使用多种技术来解决它-它不仅限于使用JavaScript完成，而且fill会填补浏览器中需要该技术的空白。它也不意味着“旧的浏览器”（因为我们也需要填充新的浏览器）</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">     <span class="comment">//防止Function.prototype.bind.call(obj,param)这种调用改变this</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">         fToBind = <span class="keyword">this</span>,</span><br><span class="line">         fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">         fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">           <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                  ? <span class="keyword">this</span></span><br><span class="line">                  : oThis,</span><br><span class="line">                  <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                  aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">         &#125;;</span><br><span class="line">     <span class="comment">// 维护原型关系</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">       <span class="comment">// 当执行Function.prototype.bind()时, this为Function.prototype </span></span><br><span class="line">       <span class="comment">// this.prototype(即Function.prototype.prototype)为undefined</span></span><br><span class="line">       fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">     <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">     fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">     <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">polyfill相关文章</a></p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>==JavaScript 采用的是词法作用域(静态的作用域)，函数的作用域在函数定义的时候就决定了==(一个函数先定义后执行，定义的时候什么都不干，但是已经锁定了其词法作用域，执行的时候有执行机上下文，会用到已经定义的词法作用域)</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><ul><li>假设JavaScript采用静态作用域，让我们分析下执行过程：<ul><li>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</li></ul></li><li>假设JavaScript采用动态作用域，让我们分析下执行过程：<ul><li>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</li></ul></li></ul><p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo1</span></span><br><span class="line"> <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>然而去看这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo2</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>可执行代码(executable code)的类型:全局代码、函数代码、eval代码。</p><p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>事实上，JS的解析过程分为两个阶段：预编译期(预处理)与执行期</strong></p><p>预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译），但需要注意的是此时处理函数的只是<strong>声明式函数</strong>，而且变量也只是进行了声明但未进行初始化以及赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//执行了定义式函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了定义式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子2</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//报错，提示函数未定义</span></span><br><span class="line">  <span class="keyword">var</span> Fun= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了赋值式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子3</span></span><br><span class="line"><span class="comment">//因为在js中重名的函数，后定义的会覆盖前面定义的函数，这种策略和js的顺序执行也是有关系的</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//它执行的结果是：弹出"执行了函数2"</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数1"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a><strong>执行上下文栈</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个函数执行的时候有执行机上下文，多个函数执行的时候有执行上下文栈 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun3'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun3();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun2();</span><br><span class="line"> &#125;</span><br><span class="line"> fun1();</span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// fun1()ECStack.push(&lt;fun1&gt; functionContext); -- fun1进栈</span></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext); -- fun2进栈</span></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext); -- fun3进栈</span></span><br><span class="line"><span class="comment">// fun3执行完毕ECStack.pop(); -- fun3出栈</span></span><br><span class="line"><span class="comment">// fun2执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// fun1执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>​    全局上下文中的变量对象就是全局对象！</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><ul><li>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</li><li>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li><li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。(只有函数才具有arguments )</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function">function <span class="title">c</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数提升</span></span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol><li>查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链</li><li><strong>函数的作用域在函数定义的时候就决定了!!!!!!</strong></li><li>这是因为函数有一个内部属性 [[scope]] (双括号表示引擎内部的变量)，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope可以理解为函数在创建时的一个属性</span></span><br><span class="line">foo.[[scope]] = [</span><br><span class="line">    globalContext.VO <span class="comment">// -- globalContext位于栈底，Vo里存放变量，这就是所有函数为什么能够拿到window变量的原因</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,<span class="comment">// bar套在foo中，所以能拿到foo的AO，(定义bar的时候,foo已经执行了)</span></span><br><span class="line">    globalContext.VO <span class="comment">// window的AO与VO相同，不需要激活</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>详见下面的例子 – 图片中只展示出来了层级关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">        <span class="built_in">console</span>.dir(bar)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.dir(foo)</span><br></pre></td></tr></table></figure><img src="/2020/04/28/bind/3.jpg"><p>​        <img src="/2020/04/28/bind/4.jpg"></p><h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时(激活通俗的理解就是执行)，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 ScopeChain</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScopeChain = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>其实很复杂，简单来说是<strong>谁调用指向谁</strong></p><h3 id="具体执行分析"><a href="#具体执行分析" class="headerlink" title="具体执行分析"></a>具体执行分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><ol><li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">   globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="2"><li>全局上下文初始化</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: [global],</span><br><span class="line">    Scope: [globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化的同时，checkscope函数被创建，保存作用域链到函数的内部属性[[scope]]</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="4"><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">      checkscopeContext,</span><br><span class="line">      globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="5"><li>checkscope 函数执行上下文初始化：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链，</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象，</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明，</span><br><span class="line">将活动对象压入 checkscope 作用域链顶端。</span><br><span class="line">同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</span><br><span class="line"></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">             &#125;,</span><br><span class="line">             scope: <span class="literal">undefined</span>,</span><br><span class="line">             f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         Scope: [AO, globalContext.VO], <span class="comment">//ScopeChan</span></span><br><span class="line">         <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">       fContext,</span><br><span class="line">       checkscopeContext,</span><br><span class="line">       globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="7"><li>f 函数执行上下文初始化, 以下跟第 4 步相同:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明</span><br><span class="line">将活动对象压入 f 作用域链顶端</span><br><span class="line"></span><br><span class="line">fContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">        <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">        globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指那些能够访问自由变量的函数（MDN）、闭包是指有权访问另外一个函数作用域中的变量的函数（红宝书p178）、《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。</p><p>从实践角度：以下函数才算是闭包：</p><ol><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> scope;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这里直接给出简要的执行过程：</p><ul><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ul><p>了解到这个过程，我们应该思考一个问题，那就是:</p><p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">     Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="call和apply的模拟实现"><a href="#call和apply的模拟实现" class="headerlink" title="call和apply的模拟实现"></a><strong>call和apply的模拟实现</strong></h2><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> args = [];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">         args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> result;</span><br><span class="line">     <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">         result = context.fn();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> args = [];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">             args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.age = age;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">this</span>.habit = <span class="string">'Games'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"> Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayYourName())<span class="comment">//I am Kevin</span></span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乞丐版：完整版很深</span></span><br><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addCurry() <span class="comment">// 3//或者var addCurry = curry(add, 1);addCurry(2) // 3//或者var addCurry = curry(add);addCurry(1, 2) // 3</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.l = length</span><br><span class="line">    <span class="keyword">this</span>.w = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.l*<span class="keyword">this</span>.w</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>)</span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>,length,length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype,&#123;</span><br><span class="line">     <span class="keyword">constructor</span>:&#123;</span><br><span class="line">     value:Square</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">// 相当于Rectangle.prototype.constructor = Square</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="/2020/04/28/bind/1.jpg"><p>爸爸的父亲等于妈妈的老公？？？</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><img src="/2020/04/28/bind/2.jpg"><p>bind()创建的function上没有prototype/箭头函数上也没有prototype</p><img src="/2020/04/28/bind/5.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是bind&quot;&gt;&lt;a href=&quot;#什么是bind&quot; class=&quot;headerlink&quot; title=&quot;什么是bind&quot;&gt;&lt;/a&gt;什么是bind&lt;/h2&gt;&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt; 方法创建一个新的函数，在 &lt;code&gt;bind()&lt;/cod
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js防抖与节流</title>
    <link href="https://lg666kkk.github.io/2020/04/28/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81-0/"/>
    <id>https://lg666kkk.github.io/2020/04/28/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81-0/</id>
    <published>2020-04-28T02:55:42.000Z</published>
    <updated>2020-04-28T03:35:09.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS防抖和节流"><a href="#JS防抖和节流" class="headerlink" title="JS防抖和节流"></a>JS防抖和节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>事件响应函数在一段时间后才执行，如果在这段时间内再次调用，则重新计算执行时间；当预定的时间内没有再次调用该函数，则执行响应逻辑</p><p><a href="http://www.underscore-js.com/functionsRelated.html" target="_blank" rel="noopener">underscore</a>中的debounce函数可以防抖</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>scroll事件滚动触发的时候</li><li>搜索框输入查询的时候</li><li>表单验证</li><li>按钮的提交事件</li><li>浏览器的窗口缩放，resize事件</li></ol><h3 id="自定义防抖函数"><a href="#自定义防抖函数" class="headerlink" title="自定义防抖函数"></a>自定义防抖函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数的自定义实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 等待的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate 是否立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result -- 返回值</span></span><br><span class="line">  <span class="keyword">let</span> timeout, result;</span><br><span class="line">  <span class="keyword">let</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span>(timeout) clearTimeout(timeout)</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// callNow是立即执行的变量</span></span><br><span class="line">      <span class="keyword">let</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="comment">// 由于最开始timeout为undefined,取反为true,故立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(self, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不会立即执行</span></span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//解决执行函数内部this指向问题以及event指向问题</span></span><br><span class="line">        result = func.apply(self, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消</span></span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = <span class="literal">null</span> <span class="comment">// 防止内存泄露</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>如果你持续的触发事件，每隔一段时间，只执行一次事件</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>DOM元素的拖拽功能的实现</li><li>计算鼠标移动的距离</li><li>监听scroll滚动事件</li></ol><h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 -- 初步实现 -- 第一次会触发，最后一次不会触发</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 等待的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args</span><br><span class="line">  <span class="comment">// 之前的时间戳</span></span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 默认为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (now-old &gt; wait) &#123;</span><br><span class="line">      <span class="comment">// 立即执行</span></span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 -- 第一次不会触发，最后一次会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再次改进版本"><a href="#再次改进版本" class="headerlink" title="再次改进版本"></a>再次改进版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * 第一次会触发，最后一次会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout</span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    old = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">    func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (now - old &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span> </span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * 最终版本</span></span><br><span class="line"><span class="comment"> * 第一次不会触发，最后一次会调用 leading:false, trailing:true</span></span><br><span class="line"><span class="comment"> * 第一次会触发，最后一次不会触发 leading:true, trailing:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout, result</span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125; </span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    old = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">    result = func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> trottled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (options.leading === <span class="literal">false</span>  &amp;&amp; !old) &#123;</span><br><span class="line">      old = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now - old &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span> </span><br><span class="line">      &#125;</span><br><span class="line">      result = func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  trottled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> trottled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS防抖和节流&quot;&gt;&lt;a href=&quot;#JS防抖和节流&quot; class=&quot;headerlink&quot; title=&quot;JS防抖和节流&quot;&gt;&lt;/a&gt;JS防抖和节流&lt;/h1&gt;&lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS深拷贝</title>
    <link href="https://lg666kkk.github.io/2020/03/28/deepCopy/"/>
    <id>https://lg666kkk.github.io/2020/03/28/deepCopy/</id>
    <published>2020-03-28T05:59:13.000Z</published>
    <updated>2020-04-28T06:06:39.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>创建了一个新的对象，这个对象有着原始对象属性值得精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a === source.a <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="判断类型的方式"><a href="#判断类型的方式" class="headerlink" title="判断类型的方式"></a>判断类型的方式</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof可以用于判断以下js的8种类型：</p><p>js的8中数据类型：</p><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li><strong>BigInt – 浏览器已经支持了</strong></li><li>String</li><li>Symbol</li><li>Object</li></ul><p>但也有缺点 — <strong>暂时性死区</strong>(TDZ)</p><p>我们知道let和const 具有暂时性死区(即在代码块内，使用let/const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”)</p><p>typeof也具有暂时性死区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError -- 声明在后导致出错</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"  -- 若一个变量根本没有声明，倒不会报错</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考烂了的面试题</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>原理： 右边变量的prototype在左边变量的原型链上即可(右边构造函数的原型在不在左边实例的原型链上)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/mefelixwang/p/7525220.html" target="_blank" rel="noopener">JS原型链神图</a></p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>将一个对象从内存中完整的拷贝出来一份，从内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象</p><h3 id="最常用的一种方式-–-业务中用-不适合于面试"><a href="#最常用的一种方式-–-业务中用-不适合于面试" class="headerlink" title="最常用的一种方式 – 业务中用(不适合于面试)"></a>最常用的一种方式 – 业务中用(不适合于面试)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(x)) <span class="comment">// 将x深拷贝给d</span></span><br></pre></td></tr></table></figure><h3 id="基本版本"><a href="#基本版本" class="headerlink" title="基本版本"></a>基本版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> newArr = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">                newArr.push(obj[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> newObj = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                newObj[key] = <span class="keyword">this</span>.deepCopy(obj[key])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试版本"><a href="#面试版本" class="headerlink" title="面试版本"></a>面试版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试版本</span></span><br><span class="line"><span class="comment">// 判断是不是一个复杂类型</span></span><br><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="keyword">function</span> (<span class="params">obj, hash= new WeakMap(</span>)) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">     <span class="keyword">let</span> type = [<span class="built_in">Date</span>, <span class="built_in">RegExp</span>, <span class="built_in">Set</span>, <span class="built_in">Map</span>, <span class="built_in">WeakMap</span>, <span class="built_in">WeakSet</span>];</span><br><span class="line">     <span class="keyword">if</span> (type.includes(obj.constructor)) <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">     <span class="comment">// 如果成环了，参数obj = obj.loop = 最初的obj 会在WeakMap中找到第一次放入的obj提前返回第一次放入WeakMap的cloneObj</span></span><br><span class="line">     <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj) <span class="comment">// 遍历传入参数所有键的特性</span></span><br><span class="line">     <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDesc) <span class="comment">// 继承原型</span></span><br><span class="line">     hash.set(obj, cloneObj)</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123; <span class="comment">//Reflect.ownKeys可以拷贝不可枚举属性和符号类型</span></span><br><span class="line">     <span class="comment">// 如果值是引用类型则递归调用deepClone</span></span><br><span class="line">     cloneObj[key] = </span><br><span class="line">          (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? deepCopy(obj[key], hash) : obj[key];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    bigInt: BigInt(<span class="number">12312</span>),</span><br><span class="line">    <span class="keyword">set</span>: new Set([2]),</span><br><span class="line">    map: new Map([['a', 222], ['b', 33]]),</span><br><span class="line">    num: 0,</span><br><span class="line">    str: '',</span><br><span class="line">    boolean: true,</span><br><span class="line">    unf: undefined,</span><br><span class="line">    nul: null,</span><br><span class="line">    obj: &#123;</span><br><span class="line">        name: <span class="string">'我是一个对象'</span>,</span><br><span class="line">        id: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是一个函数'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>),</span><br><span class="line">    reg: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'/我是一个正则/ig'</span>),</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'1'</span>)] : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'innumerable'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'不可枚举属性'</span></span><br><span class="line">&#125;)</span><br><span class="line">obj = <span class="built_in">Object</span>.create(obj, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)) </span><br><span class="line">obj.loop = obj</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">let</span> cloneObj = deepCopy(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cloneObj'</span>, cloneObj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(cloneObj)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> cloneObj[key] === <span class="string">'object'</span> || <span class="keyword">typeof</span> cloneObj[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>相同吗?`</span>, cloneObj[key] === obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>学习自京程一灯董老师课程，如有侵权，联系删除</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h2&gt;&lt;p&gt;创建了一个新的对象，这个对象有着原始对象属性值得精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://lg666kkk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS专业术语</title>
    <link href="https://lg666kkk.github.io/2019/12/06/CSSshuyu/"/>
    <id>https://lg666kkk.github.io/2019/12/06/CSSshuyu/</id>
    <published>2019-12-06T12:37:33.000Z</published>
    <updated>2019-12-20T11:58:08.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS常用专业术语"><a href="#CSS常用专业术语" class="headerlink" title="CSS常用专业术语"></a>CSS常用专业术语</h2><ol><li><p>属性：属性对应的是平常我们书面或交谈时对应的CSS中文称谓，例如height，color等</p></li><li><p>值：</p><ul><li>整数值</li><li>数值：如line-height:1.5中的1.5</li><li>百分比值</li><li>长度值：例如99px</li><li>颜色值：例如#99</li><li>字符串值等等</li></ul></li><li><p>关键字：如soild,inherit等</p></li><li><p>泛关键字：可以理解为公交车关键字，就是“所有CSS属性都可以使用的关键字”的意思。</p></li><li><p>变量：如CSS3中的currentColor等</p></li><li><p>长度单位：如px,em等(值 + 长度单位 = 长度)</p><ul><li><p>相对长度单位：</p><ul><li>相对字体长度单位<ul><li>em:其相对于当前对象内文本的font-size（如果当前对象内文本的font-size计量单位也是em，则当前对象内文本的font-size的参考对象为父元素文本font-size）。使用em可以较好的相应设备屏幕尺寸的变化，但是在进行元素设置时都需要知道父元素文本的font-size及当前对象内文本的font-size，如有遗漏可能会导致错误.</li><li>ex:字符x高度的一半，一般是字体高度一半。</li><li>rem:使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</li></ul></li><li>相对视区长度单位:vh,vw,vmin,vmax等<ul><li>视区所指为浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小)</li><li>vh:相对于视框的高度：视框高度是100vh</li><li>vw:相对于视框的宽度，视框宽度为100vw</li><li>vmin:相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">8</span>vm;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">8vmin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果视口的宽度是300mm，高度是200mm，那么上述代码中h1元素的字号将为16mm，即(8x200)/100，因为高度比宽度要小，所以计算的时候相对于高度。*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>绝对长度单位：</p><ul><li>px:像素</li><li>cm</li><li>mm</li><li>pc : 皮卡Picas (1 皮卡 = 12 点)</li><li>pt : 点Points (1点 = 1/72英寸)</li></ul></li></ul></li><li><p>功能符:值以函数的形式指定起来的，主要用来表示颜色(rgba和hsla),背景图片地址(url),计算(calc)等，如rfb(0,0,0,.5)、url(‘css-World.png’)等</p></li><li><p>属性值：属性冒号后面的所有内容</p></li><li><p>声明：属性名加上属性值就是声明</p></li><li><p>声明块：用花括号{}包裹的一系列声明</p></li><li><p>规则或者规则集：出现了选择器，并且后面还跟着声明块</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.vo</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">99px</span>;</span><br><span class="line">    <span class="attribute">color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择器:</p></li><li><p>关系选择器</p></li><li><p>@规则:指的是以@字符开始的一些规则。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS常用专业术语&quot;&gt;&lt;a href=&quot;#CSS常用专业术语&quot; class=&quot;headerlink&quot; title=&quot;CSS常用专业术语&quot;&gt;&lt;/a&gt;CSS常用专业术语&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;属性：属性对应的是平常我们书面或交谈时对应的CSS中文称谓，例如h
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="《CSS世界》" scheme="https://lg666kkk.github.io/tags/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>流、元素与基本尺寸(1)</title>
    <link href="https://lg666kkk.github.io/2019/12/06/CSSWorld1/"/>
    <id>https://lg666kkk.github.io/2019/12/06/CSSWorld1/</id>
    <published>2019-12-06T11:17:17.000Z</published>
    <updated>2019-12-06T12:41:40.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流、元素与基本尺寸"><a href="#流、元素与基本尺寸" class="headerlink" title="流、元素与基本尺寸"></a>流、元素与基本尺寸</h2><ol><li>流：实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的一套物理规则，流跟现实世界的水流有异曲同工之妙</li><li>CSS中的标签种类繁多，但通常我们把他们分为两类：块级元素(block-level element)和内联元素(inline element)  <h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4></li><li>常见的块级元素有div,li,table等，但需要注意的是块级元素和display属性值为block的元素是不一样的，例如li元素默认display值时list-item,table元素默认的display值是table，但他们均是块级元素(块级元素的基本特征：一个水平流上只显示一个元素，多个块级元素换行显示)。</li><li>由于块级元素具有换行的特性，因此理论上它可以配合clear属性来清除浮动带来的影响</li><li>浮动：元素脱离文档流，使元素在页面中水平排列<ul><li>float可选值如下：<ul><li>none默认值，元素默认在文档流中排列</li><li>left:元素立即脱离文档流，向页面左侧浮动</li><li>right:元素立即脱离文档流，向页面右侧浮动</li></ul></li><li>内联元素脱离文档流后会变成块元素</li><li>块元素脱离文档流后高度和宽度会被内容撑开</li><li>浮动的元素不会盖住文字，文字会自动环绕在浮动元素周围，所以我们可以通过浮动来设置文字环绕图片的效果</li><li>如果浮动元素上边是一个没有浮动的元素，则浮动元素不会超过块元素，浮动的元素不会超过他上边的兄弟元素</li><li>当一个元素设置为浮动以后(非none值)，元素会立即脱离文档流，脱离之后，它下面的元素会立即向上移动，元素浮动以后，会尽量向元素的左上或者是右上漂浮，直到遇到父元素的边框或者其他的浮动元素。</li></ul></li><li>消除浮动：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">clear</span>: both;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>小案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;清除浮动&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        .box&#123;</span></span><br><span class="line"><span class="regexp">            padding: 10px;</span></span><br><span class="line"><span class="regexp">            background-color:#cd0000;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .box &gt; img &#123;</span></span><br><span class="line"><span class="regexp">            float:left;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .clear::after&#123;</span></span><br><span class="line"><span class="regexp">            content: "";</span></span><br><span class="line"><span class="regexp">            display: block;</span></span><br><span class="line"><span class="regexp">            clear: both;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="box clear"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img src="../img</span><span class="regexp">/1.jpg" alt="功夫熊猫"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流、元素与基本尺寸&quot;&gt;&lt;a href=&quot;#流、元素与基本尺寸&quot; class=&quot;headerlink&quot; title=&quot;流、元素与基本尺寸&quot;&gt;&lt;/a&gt;流、元素与基本尺寸&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;流：实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="《CSS世界》" scheme="https://lg666kkk.github.io/tags/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>GitHub使用技巧(一)</title>
    <link href="https://lg666kkk.github.io/2019/11/16/githu/"/>
    <id>https://lg666kkk.github.io/2019/11/16/githu/</id>
    <published>2019-11-16T15:00:40.000Z</published>
    <updated>2019-11-16T15:37:14.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub使用小技巧-一"><a href="#GitHub使用小技巧-一" class="headerlink" title="GitHub使用小技巧(一)"></a>GitHub使用小技巧(一)</h2><h3 id="在GitHub中搜索你所需要的知识得一些小窍门"><a href="#在GitHub中搜索你所需要的知识得一些小窍门" class="headerlink" title="在GitHub中搜索你所需要的知识得一些小窍门"></a>在GitHub中搜索你所需要的知识得一些小窍门</h3><p>   在日常的学习中，我们很多时间需要去从GitHub上寻找一些开源项目<br>   首先，我们需要了解GitHub上面开源项目的一些基本知识：项目名,项目源码，项目描述，Readme.md，star,fork数，更新日期等等</p><ol><li>in:name 搜索关键字   —-在GitHub项目名上精确搜索，如：in:name app开发，可找到所有项目名中包含“app开发”的项目</li><li>stars: 整数          —–GitHub项目的star数目，例如你要找star数目大于3000的项目，stars:&gt;3000</li><li>forks: 整数          ——GitHub项目fork数目，与star数目用法相同</li><li>in:readme 搜索关键字  ——-在Readme中搜索</li><li>in:discription 搜索关键字   ——在描述里面搜索你所需要的内容</li><li>language:语言名   —— 如需要搜索java项目；language:java即可</li><li>pushed: 日期    ——-根据日期进行搜索，例如搜索2019年11月2日以后更新的项目, pushed:&gt;2019-11-02</li><li>以上7点可以混合使用，以使你的搜索更加精确，找到你感兴趣的东西。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GitHub使用小技巧-一&quot;&gt;&lt;a href=&quot;#GitHub使用小技巧-一&quot; class=&quot;headerlink&quot; title=&quot;GitHub使用小技巧(一)&quot;&gt;&lt;/a&gt;GitHub使用小技巧(一)&lt;/h2&gt;&lt;h3 id=&quot;在GitHub中搜索你所需要的知识得一
      
    
    </summary>
    
    
      <category term="GitHub" scheme="https://lg666kkk.github.io/categories/GitHub/"/>
    
    
      <category term="Github使用小技巧" scheme="https://lg666kkk.github.io/tags/Github%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>55-跳跃游戏</title>
    <link href="https://lg666kkk.github.io/2019/11/09/sf3/"/>
    <id>https://lg666kkk.github.io/2019/11/09/sf3/</id>
    <published>2019-11-09T15:03:48.000Z</published>
    <updated>2019-11-09T15:20:38.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>题目：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><ol><li>解法一：<ul><li>解题思路：最容易想到的方法，直接遍历每一种可能的情况，暴力破解，但是这个方法超时(哭了)</li><li>代码如下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">canJumpyue</span>(<span class="params">position , nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//到达最后一个，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span>(position == nums.length<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> JumpLength = <span class="built_in">Math</span>.min(position+nums[position],nums.length<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//遍历所有的可能路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> nextposition = position + <span class="number">1</span>;nextposition &lt;= JumpLength;nextposition++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(canJumpyue(nextposition,nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpyue(<span class="number">0</span>,nums);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h2&gt;&lt;p&gt;题目：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="https://lg666kkk.github.io/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心策略" scheme="https://lg666kkk.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu系统重装</title>
    <link href="https://lg666kkk.github.io/2019/10/31/ub2/"/>
    <id>https://lg666kkk.github.io/2019/10/31/ub2/</id>
    <published>2019-10-31T12:38:20.000Z</published>
    <updated>2019-10-31T12:50:16.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu系统重装-链接如下"><a href="#ubuntu系统重装-链接如下" class="headerlink" title="ubuntu系统重装(链接如下)"></a>ubuntu系统重装(链接如下)</h2><p><a href="https://blog.csdn.net/tjuyanming/article/details/64929901" target="_blank" rel="noopener">UEFI启动Windows10+Ubuntu双系统删除Ubuntu方法</a><br><a href="https://www.jianshu.com/p/0726b0cbed0e" target="_blank" rel="noopener">安装win10+ubuntu18.04双系统</a><br><a href="https://www.jianshu.com/p/66a092caaa36" target="_blank" rel="noopener">在Win10与Ubuntu双系统中删除Ubuntu</a></p><blockquote><p>如有侵权，请联系删除</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ubuntu系统重装-链接如下&quot;&gt;&lt;a href=&quot;#ubuntu系统重装-链接如下&quot; class=&quot;headerlink&quot; title=&quot;ubuntu系统重装(链接如下)&quot;&gt;&lt;/a&gt;ubuntu系统重装(链接如下)&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://lg666kkk.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://lg666kkk.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>44--通配符匹配</title>
    <link href="https://lg666kkk.github.io/2019/10/24/stringMatch/"/>
    <id>https://lg666kkk.github.io/2019/10/24/stringMatch/</id>
    <published>2019-10-24T14:28:10.000Z</published>
    <updated>2019-10-26T12:53:22.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><ol><li><p>问题描述<br>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘ ? ‘ 和 ‘ * ‘ 的通配符匹配。<br>‘ ? ‘ 可以匹配任何单个字符。<br>‘ * ‘ 可以匹配任意字符串（包括空字符串）<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符  ?  和  *</p></li><li><p>代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star=<span class="number">-1</span>, match=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sp=<span class="number">0</span>, pp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sp &lt; s.length)&#123;</span><br><span class="line">     <span class="keyword">if</span>(pp&lt;p.length &amp;&amp; (s[sp] == p[pp] || p[pp] ==<span class="string">"?"</span>))&#123;</span><br><span class="line">           sp++;</span><br><span class="line">           pp++;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp&lt;p.length &amp;&amp; p[pp] == <span class="string">"*"</span>)&#123;</span><br><span class="line">           star = pp;</span><br><span class="line">           match = sp;</span><br><span class="line">           pp++;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(star != <span class="number">-1</span>)&#123;</span><br><span class="line">           pp = star + <span class="number">1</span>;</span><br><span class="line">           match++;</span><br><span class="line">           sp = match;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span> (pp &lt; p.length &amp;&amp; p[pp] == <span class="string">'*'</span>) pp++;</span><br><span class="line">    <span class="keyword">return</span> pp == p.length;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通配符匹配&quot;&gt;&lt;a href=&quot;#通配符匹配&quot; class=&quot;headerlink&quot; title=&quot;通配符匹配&quot;&gt;&lt;/a&gt;通配符匹配&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;问题描述&lt;br&gt;给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘ ? ‘ 和 ‘
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="https://lg666kkk.github.io/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心策略" scheme="https://lg666kkk.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>H5学习笔记(一)</title>
    <link href="https://lg666kkk.github.io/2019/10/07/h5-1/"/>
    <id>https://lg666kkk.github.io/2019/10/07/h5-1/</id>
    <published>2019-10-07T11:59:59.000Z</published>
    <updated>2019-11-09T15:25:49.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="H5学习笔记-一"><a href="#H5学习笔记-一" class="headerlink" title="H5学习笔记(一)"></a>H5学习笔记(一)</h2><ol><li>H5中的一些新增标签<ul><li>canvas 标签，用于JS绘图</li><li>audio 标签，用于定义音频内容</li><li>video 标签，用于定义视频内容</li><li>embed 标签，定义嵌入的内容，比如插件</li><li>article 标签，定义页面的侧边栏内容</li><li>aside 标签，定义页面内容之外的内容</li><li>footer 标签，定义section或document的页脚</li><li>header 标签，定义文档的头部区域</li><li>meter 标签，定义度量衡，仅用于已知最大和最小的度量</li><li>nav 标签，定义运行中的进度（进程）</li><li>section 标签，定义文档中的节(section 、区段)</li><li>datalist标签，为表单新增标签，常与input配合使用，类似于拥有输入功能的下拉列表</li><li>output标签，用于展示内容，只能展示，不能用来编辑<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>文档头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span>页面侧边栏内容<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span>&gt;</span>页面内容之外的内容<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>定义页脚<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>新增表单的输入类型<ul><li>email: 输入email格式</li><li>tel: 手机号码</li><li>url:只能输入url格式</li><li>number：只能输入数字</li><li>search: 搜索框</li><li>range : 范围，可以进行拖动，进行value取值</li><li>color : 拾色器，通过value进行取值</li><li>time ： 时间</li><li>data : 日期</li><li>datatime : 时间日期</li><li>month : 月份</li><li>week : 星期</li></ul></li><li>表单新增事件<ul><li>oninput 用户输入内容时触发，可用于移动端的输入字数统计</li><li>oninvaild 验证不通过时触发</li></ul></li><li>表单新增属性<ul><li>placeholder 占位符</li><li>autofocus 获取焦点</li><li>multiple 文件上传多选或多个邮箱地址</li><li>form 指定表单向属于哪个form,处理复杂表单时会需要</li><li>autocomplete 自动完成，用于表单元素，也可用于表单自身</li><li>novalidate 关闭验证，可用于form标签</li><li>required 验证条件，必填项</li><li>pattern 正则表达式，验证表单</li></ul></li><li>案例：详见我的CSDN上的 H5简易登录界面那一篇博客</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;H5学习笔记-一&quot;&gt;&lt;a href=&quot;#H5学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;H5学习笔记(一)&quot;&gt;&lt;/a&gt;H5学习笔记(一)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;H5中的一些新增标签&lt;ul&gt;
&lt;li&gt;canvas 标签，用于JS绘图&lt;/l
      
    
    </summary>
    
    
      <category term="前端" scheme="https://lg666kkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5学习" scheme="https://lg666kkk.github.io/tags/H5%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://lg666kkk.github.io/2019/09/05/sf1/"/>
    <id>https://lg666kkk.github.io/2019/09/05/sf1/</id>
    <published>2019-09-05T13:07:58.000Z</published>
    <updated>2019-10-17T14:52:01.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><ol><li>问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</li><li>代码<ul><li>方法一: 执行用时：132 ms<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span> ; j&lt;nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]+nums[j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> [k , j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>方法二:执行用时：56 ms<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//Map是一组键值对的结构</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nums.length ; i++)&#123;</span><br><span class="line">   <span class="comment">//设置键值对:map.set(key , value)</span></span><br><span class="line">       map.set(nums[i],i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">   <span class="comment">//map.has()返回布尔值,查询key是否在当前对象中</span></span><br><span class="line">   <span class="comment">//map.get()获取key对应的键值,若没有则返回undefined</span></span><br><span class="line">       <span class="keyword">if</span>(map.has(target-nums[j])&amp;&amp;map.get(target-nums[j])!=j)&#123;</span><br><span class="line">             <span class="keyword">return</span> [j,map.get(target - nums[j])];</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="https://lg666kkk.github.io/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode简单算法" scheme="https://lg666kkk.github.io/tags/leetcode%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu分辨率问题</title>
    <link href="https://lg666kkk.github.io/2019/09/05/ub1/"/>
    <id>https://lg666kkk.github.io/2019/09/05/ub1/</id>
    <published>2019-09-05T09:36:28.000Z</published>
    <updated>2019-10-17T14:54:39.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决安装双系统后ubuntu系统只有一个分辨率问题"><a href="#解决安装双系统后ubuntu系统只有一个分辨率问题" class="headerlink" title="解决安装双系统后ubuntu系统只有一个分辨率问题"></a>解决安装双系统后ubuntu系统只有一个分辨率问题</h2><ol><li><p>问题描述：<br>在windows系统的基础上安装了ubuntu18.04之后，发现系统的分辨率只有800*600一个分辨率，并且不能使用xrandr修改分辨率，使用xrandr命令报xrandr failed to get size of gamma for output default错误，找了很多教程，都出现了问题，最会终于解决了。</p></li><li><p>解决方法:</p><ul><li>首先在打开Ubuntu命令行执行如下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure></li><li>然后找到#GRUB_GFXMODE=800x600这行，把800x600改成你想要的分辨率，比如1920x1080，并去掉这一行前面的#，改后变为GRUB_GFXMODE=1920x1080 ，然后保存.</li><li>打开终端用命令更新grub：sudo update-grub</li><li>重启，如果分辨率修改成功就不必再进行一下步骤了。</li><li>如没有成功就有可能是驱动问题</li><li>先执行如下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit  /etc/xorg.conf</span><br></pre></td></tr></table></figure></li><li>复制以下内容放入打开文档：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">Identifier   &quot;Monitor0&quot;</span><br><span class="line">VendorName   &quot;Monitor Vendor&quot;</span><br><span class="line">ModelName    &quot;Monitor Model&quot;</span><br><span class="line">HorizSync   28.0 - 70.0</span><br><span class="line">VertRefresh     56.0 - 75.0</span><br><span class="line">EndSection</span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">Identifier  &quot;VMware SVGA&quot;</span><br><span class="line">Driver      &quot;vesa&quot;</span><br><span class="line">EndSection</span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">Identifier &quot;Screen0&quot;</span><br><span class="line">Device     &quot;Card0&quot;</span><br><span class="line">Monitor    &quot;Monitor0&quot;</span><br><span class="line">SubSection &quot;Display&quot;</span><br><span class="line">Viewport   0 0</span><br><span class="line">Depth     24</span><br><span class="line">Modes     &quot;1920x1080_60.00&quot;</span><br><span class="line">EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure></li><li>执行以下命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/default/grub 或 sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><ul><li>编辑打开的文件，找到GRUB_CMDLINE_LINUX_DEFAULT那一行，在后面加上(在quiet splash后打一个空格) nomodeset（保险起见，nomodeset后面加多一个空格），保存，然后在终端输入 sudo update-grub</li><li>然后下载驱动：系统设置–软件和更新–附加驱动  里面使用NVIDIA的专有驱动，第一个即可(驱动名称后面的括号里是专有，tested的那个)</li><li>下载完驱动后，重启即可，此时应该修改成功了</li></ul></li></ol><blockquote><p>随手而记，以防需要之时翻找</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解决安装双系统后ubuntu系统只有一个分辨率问题&quot;&gt;&lt;a href=&quot;#解决安装双系统后ubuntu系统只有一个分辨率问题&quot; class=&quot;headerlink&quot; title=&quot;解决安装双系统后ubuntu系统只有一个分辨率问题&quot;&gt;&lt;/a&gt;解决安装双系统后ubu
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://lg666kkk.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://lg666kkk.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>《活着》</title>
    <link href="https://lg666kkk.github.io/2019/08/22/reader1/"/>
    <id>https://lg666kkk.github.io/2019/08/22/reader1/</id>
    <published>2019-08-22T11:42:09.000Z</published>
    <updated>2019-09-05T10:24:55.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《活着》"><a href="#《活着》" class="headerlink" title="《活着》"></a>《活着》</h2><hr><p>   今天在微信读书上又翻了一遍《活着》，无意间看到了一位书友的评论，他的评论是引用了茨威格的一句话：<strong>那时候还年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。</strong>  </p><p>   觉得这句话很有道理，感触颇深，随手而记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;《活着》&quot;&gt;&lt;a href=&quot;#《活着》&quot; class=&quot;headerlink&quot; title=&quot;《活着》&quot;&gt;&lt;/a&gt;《活着》&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;   今天在微信读书上又翻了一遍《活着》，无意间看到了一位书友的评论，他的评论是引用了茨威格的一句话：&lt;stron
      
    
    </summary>
    
    
      <category term="读书笔记及随笔" scheme="https://lg666kkk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8F%8A%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="读书笔记" scheme="https://lg666kkk.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
