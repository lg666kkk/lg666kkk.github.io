<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JS中的bind"><meta name="keywords" content="JavaScript"><meta name="author" content="lg,undefined"><meta name="copyright" content="lg"><title>JS中的bind【Charles's Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Charles's Blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是bind"><span class="toc-number">1.</span> <span class="toc-text">什么是bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法"><span class="toc-number">2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数"><span class="toc-number">2.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回值"><span class="toc-number">2.2.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind特点"><span class="toc-number">3.</span> <span class="toc-text">bind特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mdn的Polyfill"><span class="toc-number">4.</span> <span class="toc-text">mdn的Polyfill</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码如下"><span class="toc-number">4.1.</span> <span class="toc-text">代码如下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#词法作用域"><span class="toc-number">5.</span> <span class="toc-text">词法作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行顺序"><span class="toc-number">6.</span> <span class="toc-text">执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">6.1.</span> <span class="toc-text">补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文栈"><span class="toc-number">6.2.</span> <span class="toc-text">执行上下文栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量对象"><span class="toc-number">7.</span> <span class="toc-text">变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局上下文"><span class="toc-number">7.1.</span> <span class="toc-text">全局上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数上下文"><span class="toc-number">7.2.</span> <span class="toc-text">函数上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行过程"><span class="toc-number">8.</span> <span class="toc-text">执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进入执行上下文"><span class="toc-number">8.1.</span> <span class="toc-text">进入执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码执行"><span class="toc-number">8.2.</span> <span class="toc-text">代码执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域链"><span class="toc-number">9.</span> <span class="toc-text">作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数激活"><span class="toc-number">9.1.</span> <span class="toc-text">函数激活</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">10.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#具体执行分析"><span class="toc-number">10.1.</span> <span class="toc-text">具体执行分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">11.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-number">11.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">11.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call和apply的模拟实现"><span class="toc-number">12.</span> <span class="toc-text">call和apply的模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new"><span class="toc-number">13.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#柯里化"><span class="toc-number">14.</span> <span class="toc-text">柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">15.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-number">16.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后续"><span class="toc-number">17.</span> <span class="toc-text">后续</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.jpg"></div><div class="author-info-name">lg</div><div class="author-info-description">Success is to do simple things repeatedly.</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/lg666kkk" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="mailto:17358183496@163.com" target="_blank">E-Mail<i class="icon-dot bg-color10"></i></a><a class="links-button button-hover" href="tencent://message/?uin=3496294573&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">31</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">14</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">6</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://blog.csdn.net/qq_44363897" target="_blank">csdn博客</a><a class="friend-link-text" href="https://www.facebook.com/lwllg.guang" target="_blank">facebook</a><a class="friend-link-text" href="https://t.me/lg6666" target="_blank">Twitter</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Charles's Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JS中的bind</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-04-28 | 更新于 2020-04-28</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div></div><div class="main-content"><h2 id="什么是bind"><a href="#什么是bind" class="headerlink" title="什么是bind"></a>什么是bind</h2><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>thisArg</li>
</ol>
<ul>
<li>调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a>运算符构造绑定函数，则忽略该值。当使用 <code>bind</code> 在 <code>setTimeout</code> 中创建一个函数（作为回调提供）时，作为 <code>thisArg</code> 传递的任何原始值都将转换为 <code>object</code>。如果 <code>bind</code> 函数的参数列表为空，执行作用域的 <code>this</code> 将被视为新函数的 <code>thisArg</code>。</li>
</ul>
<ol start="2">
<li><code>arg1, arg2, ...</code></li>
</ol>
<ul>
<li>当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个原函数的拷贝，并拥有指定的 <strong>this</strong> 值和初始参数</p>
<h2 id="bind特点"><a href="#bind特点" class="headerlink" title="bind特点"></a>bind特点</h2><ol>
<li>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this(js的this是动态的，改变this有三种方式call,apply,bind)，之后的一序列参数将会在传递的实参前传入作为它的参数。</li>
<li>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被略，同时调用时的参数被提供给模拟函数。</li>
</ol>
<h2 id="mdn的Polyfill"><a href="#mdn的Polyfill" class="headerlink" title="mdn的Polyfill"></a>mdn的Polyfill</h2><p>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。</p>
<p>比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/text-shadow" target="_blank" rel="noopener"><code>text-shadow</code></a>，或其他任何你想要的功能</p>
<p>Poly表示可以使用多种技术来解决它-它不仅限于使用JavaScript完成，而且fill会填补浏览器中需要该技术的空白。它也不意味着“旧的浏览器”（因为我们也需要填充新的浏览器）</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">     <span class="comment">//防止Function.prototype.bind.call(obj,param)这种调用改变this</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not 			callable'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">         fToBind = <span class="keyword">this</span>,</span><br><span class="line">         fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">         fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">           <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                  ? <span class="keyword">this</span></span><br><span class="line">                  : oThis,</span><br><span class="line">                  <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                  aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">         &#125;;</span><br><span class="line">     <span class="comment">// 维护原型关系</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">       <span class="comment">// 当执行Function.prototype.bind()时, this为Function.prototype </span></span><br><span class="line">       <span class="comment">// this.prototype(即Function.prototype.prototype)为undefined</span></span><br><span class="line">       fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">     <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的		实例</span></span><br><span class="line">     fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">     <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">polyfill相关文章</a></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>==JavaScript 采用的是词法作用域(静态的作用域)，函数的作用域在函数定义的时候就决定了==(一个函数先定义后执行，定义的时候什么都不干，但是已经锁定了其词法作用域，执行的时候有执行机上下文，会用到已经定义的词法作用域)</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<ul>
<li>假设JavaScript采用静态作用域，让我们分析下执行过程：<ul>
<li>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</li>
</ul>
</li>
<li>假设JavaScript采用动态作用域，让我们分析下执行过程：<ul>
<li>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</li>
</ul>
</li>
</ul>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo1</span></span><br><span class="line"> <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure>

<p>然而去看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo2</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure>



<p>可执行代码(executable code)的类型:全局代码、函数代码、eval代码。</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>事实上，JS的解析过程分为两个阶段：预编译期(预处理)与执行期</strong></p>
<p>预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译），但需要注意的是此时处理函数的只是<strong>声明式函数</strong>，而且变量也只是进行了声明但未进行初始化以及赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//执行了定义式函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了定义式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子2</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//报错，提示函数未定义</span></span><br><span class="line">  <span class="keyword">var</span> Fun= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了赋值式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子3</span></span><br><span class="line"><span class="comment">//因为在js中重名的函数，后定义的会覆盖前面定义的函数，这种策略和js的顺序执行也是有关系的</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//它执行的结果是：弹出"执行了函数2"</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数1"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a><strong>执行上下文栈</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个函数执行的时候有执行机上下文，多个函数执行的时候有执行上下文栈 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun3'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun3();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun2();</span><br><span class="line"> &#125;</span><br><span class="line"> fun1();</span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// fun1()ECStack.push(&lt;fun1&gt; functionContext); -- fun1进栈</span></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext); -- fun2进栈</span></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext); -- fun3进栈</span></span><br><span class="line"><span class="comment">// fun3执行完毕ECStack.pop(); -- fun3出栈</span></span><br><span class="line"><span class="comment">// fun2执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// fun1执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure>

<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>​    全局上下文中的变量对象就是全局对象！</p>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><ul>
<li>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</li>
<li>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li>
<li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。(只有函数才具有arguments )</li>
</ul>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function">function <span class="title">c</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数提升</span></span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol>
<li>查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链</li>
<li><strong>函数的作用域在函数定义的时候就决定了!!!!!!</strong></li>
<li>这是因为函数有一个内部属性 [[scope]] (双括号表示引擎内部的变量)，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope可以理解为函数在创建时的一个属性</span></span><br><span class="line">foo.[[scope]] = [</span><br><span class="line">    globalContext.VO <span class="comment">// -- globalContext位于栈底，Vo里存放变量，这就是所有函数为什么能够拿到window变量的原因</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,<span class="comment">// bar套在foo中，所以能拿到foo的AO，(定义bar的时候,foo已经执行了)</span></span><br><span class="line">    globalContext.VO <span class="comment">// window的AO与VO相同，不需要激活</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>详见下面的例子 – 图片中只展示出来了层级关系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">        <span class="built_in">console</span>.dir(bar)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.dir(foo)</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/bind/3.jpg">

<p>​        <img src="/2020/04/28/bind/4.jpg"></p>
<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时(激活通俗的理解就是执行)，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p>
<p>这时候执行上下文的作用域链，我们命名为 ScopeChain</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScopeChain = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>其实很复杂，简单来说是<strong>谁调用指向谁</strong></p>
<h3 id="具体执行分析"><a href="#具体执行分析" class="headerlink" title="具体执行分析"></a>具体执行分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<ol>
<li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">   globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全局上下文初始化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: [global],</span><br><span class="line">    Scope: [globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化的同时，checkscope函数被创建，保存作用域链到函数的内部属性[[scope]]</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">      checkscopeContext,</span><br><span class="line">      globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>checkscope 函数执行上下文初始化：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链，</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象，</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明，</span><br><span class="line">将活动对象压入 checkscope 作用域链顶端。</span><br><span class="line">同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</span><br><span class="line"></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">             &#125;,</span><br><span class="line">             scope: <span class="literal">undefined</span>,</span><br><span class="line">             f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         Scope: [AO, globalContext.VO], <span class="comment">//ScopeChan</span></span><br><span class="line">         <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">       fContext,</span><br><span class="line">       checkscopeContext,</span><br><span class="line">       globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>f 函数执行上下文初始化, 以下跟第 4 步相同:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明</span><br><span class="line">将活动对象压入 f 作用域链顶端</span><br><span class="line"></span><br><span class="line">fContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">        <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">        globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指那些能够访问自由变量的函数（MDN）、闭包是指有权访问另外一个函数作用域中的变量的函数（红宝书p178）、《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> scope;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这里直接给出简要的执行过程：</p>
<ul>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ul>
<p>了解到这个过程，我们应该思考一个问题，那就是:</p>
<p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p>
<p>我们知道 f 执行上下文维护了一个作用域链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">     Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call和apply的模拟实现"><a href="#call和apply的模拟实现" class="headerlink" title="call和apply的模拟实现"></a><strong>call和apply的模拟实现</strong></h2><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> args = [];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">         args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> result;</span><br><span class="line">     <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">         result = context.fn();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> args = [];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">             args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.age = age;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">this</span>.habit = <span class="string">'Games'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"> Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayYourName())<span class="comment">//I am Kevin</span></span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乞丐版：完整版很深</span></span><br><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addCurry() <span class="comment">// 3//或者var addCurry = curry(add, 1);addCurry(2) // 3//或者var addCurry = curry(add);addCurry(1, 2) // 3</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.l = length</span><br><span class="line">    <span class="keyword">this</span>.w = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.l*<span class="keyword">this</span>.w</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>)</span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>,length,length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype,&#123;</span><br><span class="line">     <span class="keyword">constructor</span>:&#123;</span><br><span class="line">     	value:Square</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">// 相当于Rectangle.prototype.constructor = Square</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="/2020/04/28/bind/1.jpg">

<p>爸爸的父亲等于妈妈的老公？？？</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><img src="/2020/04/28/bind/2.jpg">

<p>bind()创建的function上没有prototype/箭头函数上也没有prototype</p>
<img src="/2020/04/28/bind/5.jpg">



</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lg</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://lg666kkk.github.io/2020/04/28/bind/">https://lg666kkk.github.io/2020/04/28/bind/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lg666kkk.github.io">Charles's Blog</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/04/28/bind1/"><i class="fas fa-angle-left">&nbsp;</i><span>bind函数补充</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/04/28/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81-0/"><span>Js防抖与节流</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 ～ 2023 By lg</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>