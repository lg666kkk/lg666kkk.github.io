<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Success is to do simple things repeatedly."><meta name="keywords"><meta name="author" content="lg,undefined"><meta name="copyright" content="lg"><title>【Charles's Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Charles's Blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">lg</div><div class="author-info-description">Success is to do simple things repeatedly.</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fan-lv" target="_blank">GitHub<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="mailto:15757856604@163.com" target="_blank">E-Mail<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1019593584&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">31</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">14</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">6</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Charles's Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/04/28/bind1/">bind函数补充</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div><div class="post-content"><div class="main-content content"><h2 id="bind返回函数被当成构造函数的情况"><a href="#bind返回函数被当成构造函数的情况" class="headerlink" title="bind返回函数被当成构造函数的情况"></a>bind返回函数被当成构造函数的情况</h2><p>在MDN中有这么一句话</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind()中的第一个参数：调用绑定函数时作为 <span class="keyword">this</span> 参数传递给目标函数的值。</span><br><span class="line">如果使用<span class="keyword">new</span>运算符构造绑定函数，则忽略该值</span><br></pre></td></tr></table></figure>

<p>那么这句话啥意思呢？？</p>
<p>首先，我们都知道bind()会返回一个新的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时this不再指向传入给bind的第一个参数，而是指向用new创建的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = func.bind(obj)</span><br><span class="line">newObj()</span><br><span class="line"><span class="comment">//&#123;a:1, say:f&#125; 此时this指向obj</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// func&#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = func.bind(obj)</span><br><span class="line"><span class="comment">// 若将返回的函数作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> newObj(<span class="string">'seven'</span>)</span><br><span class="line"><span class="comment">//this的指向发生了改变，指向原函数，并且可以访问原函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'o'</span>, o);</span><br><span class="line"><span class="comment">// func&#123;name:'seven'&#125;</span></span><br><span class="line">o.hello() <span class="comment">// seven</span></span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/2020/04/28/bind1/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/04/28/bind/">JS中的bind</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div><div class="post-content"><div class="main-content content"><h2 id="什么是bind"><a href="#什么是bind" class="headerlink" title="什么是bind"></a>什么是bind</h2><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>thisArg</li>
</ol>
<ul>
<li>调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code></a>运算符构造绑定函数，则忽略该值。当使用 <code>bind</code> 在 <code>setTimeout</code> 中创建一个函数（作为回调提供）时，作为 <code>thisArg</code> 传递的任何原始值都将转换为 <code>object</code>。如果 <code>bind</code> 函数的参数列表为空，执行作用域的 <code>this</code> 将被视为新函数的 <code>thisArg</code>。</li>
</ul>
<ol start="2">
<li><code>arg1, arg2, ...</code></li>
</ol>
<ul>
<li>当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个原函数的拷贝，并拥有指定的 <strong>this</strong> 值和初始参数</p>
<h2 id="bind特点"><a href="#bind特点" class="headerlink" title="bind特点"></a>bind特点</h2><ol>
<li>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this(js的this是动态的，改变this有三种方式call,apply,bind)，之后的一序列参数将会在传递的实参前传入作为它的参数。</li>
<li>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被略，同时调用时的参数被提供给模拟函数。</li>
</ol>
<h2 id="mdn的Polyfill"><a href="#mdn的Polyfill" class="headerlink" title="mdn的Polyfill"></a>mdn的Polyfill</h2><p>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。</p>
<p>比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/text-shadow" target="_blank" rel="noopener"><code>text-shadow</code></a>，或其他任何你想要的功能</p>
<p>Poly表示可以使用多种技术来解决它-它不仅限于使用JavaScript完成，而且fill会填补浏览器中需要该技术的空白。它也不意味着“旧的浏览器”（因为我们也需要填充新的浏览器）</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">     <span class="comment">//防止Function.prototype.bind.call(obj,param)这种调用改变this</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not 			callable'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">         fToBind = <span class="keyword">this</span>,</span><br><span class="line">         fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">         fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">           <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                  ? <span class="keyword">this</span></span><br><span class="line">                  : oThis,</span><br><span class="line">                  <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                  aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">         &#125;;</span><br><span class="line">     <span class="comment">// 维护原型关系</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">       <span class="comment">// 当执行Function.prototype.bind()时, this为Function.prototype </span></span><br><span class="line">       <span class="comment">// this.prototype(即Function.prototype.prototype)为undefined</span></span><br><span class="line">       fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">     <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的		实例</span></span><br><span class="line">     fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">     <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">polyfill相关文章</a></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>==JavaScript 采用的是词法作用域(静态的作用域)，函数的作用域在函数定义的时候就决定了==(一个函数先定义后执行，定义的时候什么都不干，但是已经锁定了其词法作用域，执行的时候有执行机上下文，会用到已经定义的词法作用域)</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<ul>
<li>假设JavaScript采用静态作用域，让我们分析下执行过程：<ul>
<li>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</li>
</ul>
</li>
<li>假设JavaScript采用动态作用域，让我们分析下执行过程：<ul>
<li>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</li>
</ul>
</li>
</ul>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo1</span></span><br><span class="line"> <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure>

<p>然而去看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo();  <span class="comment">// foo2</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure>



<p>可执行代码(executable code)的类型:全局代码、函数代码、eval代码。</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>事实上，JS的解析过程分为两个阶段：预编译期(预处理)与执行期</strong></p>
<p>预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译），但需要注意的是此时处理函数的只是<strong>声明式函数</strong>，而且变量也只是进行了声明但未进行初始化以及赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//执行了定义式函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了定义式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子2</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//报错，提示函数未定义</span></span><br><span class="line">  <span class="keyword">var</span> Fun= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了赋值式函数"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子3</span></span><br><span class="line"><span class="comment">//因为在js中重名的函数，后定义的会覆盖前面定义的函数，这种策略和js的顺序执行也是有关系的</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   Fn(); <span class="comment">//它执行的结果是：弹出"执行了函数2"</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数1"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"执行了函数2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a><strong>执行上下文栈</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个函数执行的时候有执行机上下文，多个函数执行的时候有执行上下文栈 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun3'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun3();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     fun2();</span><br><span class="line"> &#125;</span><br><span class="line"> fun1();</span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="comment">// fun1()ECStack.push(&lt;fun1&gt; functionContext); -- fun1进栈</span></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext); -- fun2进栈</span></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext); -- fun3进栈</span></span><br><span class="line"><span class="comment">// fun3执行完毕ECStack.pop(); -- fun3出栈</span></span><br><span class="line"><span class="comment">// fun2执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// fun1执行完毕ECStack.pop(); -- 。。</span></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure>

<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>​    全局上下文中的变量对象就是全局对象！</p>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><ul>
<li>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</li>
<li>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li>
<li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。(只有函数才具有arguments )</li>
</ul>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function">function <span class="title">c</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数提升</span></span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol>
<li>查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链</li>
<li><strong>函数的作用域在函数定义的时候就决定了!!!!!!</strong></li>
<li>这是因为函数有一个内部属性 [[scope]] (双括号表示引擎内部的变量)，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope可以理解为函数在创建时的一个属性</span></span><br><span class="line">foo.[[scope]] = [</span><br><span class="line">    globalContext.VO <span class="comment">// -- globalContext位于栈底，Vo里存放变量，这就是所有函数为什么能够拿到window变量的原因</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,<span class="comment">// bar套在foo中，所以能拿到foo的AO，(定义bar的时候,foo已经执行了)</span></span><br><span class="line">    globalContext.VO <span class="comment">// window的AO与VO相同，不需要激活</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>详见下面的例子 – 图片中只展示出来了层级关系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">        <span class="built_in">console</span>.dir(bar)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.dir(foo)</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/bind/3.jpg">

<p>​        <img src="/2020/04/28/bind/4.jpg"></p>
<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时(激活通俗的理解就是执行)，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p>
<p>这时候执行上下文的作用域链，我们命名为 ScopeChain</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScopeChain = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>其实很复杂，简单来说是<strong>谁调用指向谁</strong></p>
<h3 id="具体执行分析"><a href="#具体执行分析" class="headerlink" title="具体执行分析"></a>具体执行分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<ol>
<li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">   globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全局上下文初始化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: [global],</span><br><span class="line">    Scope: [globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化的同时，checkscope函数被创建，保存作用域链到函数的内部属性[[scope]]</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">      checkscopeContext,</span><br><span class="line">      globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>checkscope 函数执行上下文初始化：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链，</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象，</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明，</span><br><span class="line">将活动对象压入 checkscope 作用域链顶端。</span><br><span class="line">同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</span><br><span class="line"></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">             &#125;,</span><br><span class="line">             scope: <span class="literal">undefined</span>,</span><br><span class="line">             f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         Scope: [AO, globalContext.VO], <span class="comment">//ScopeChan</span></span><br><span class="line">         <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">       fContext,</span><br><span class="line">       checkscopeContext,</span><br><span class="line">       globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>f 函数执行上下文初始化, 以下跟第 4 步相同:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">复制函数 [[scope]] 属性创建作用域链</span><br><span class="line">用 <span class="built_in">arguments</span> 创建活动对象</span><br><span class="line">初始化活动对象，即加入形参、函数声明、变量声明</span><br><span class="line">将活动对象压入 f 作用域链顶端</span><br><span class="line"></span><br><span class="line">fContext = &#123;</span><br><span class="line">         AO: &#123;</span><br><span class="line">             <span class="built_in">arguments</span>: &#123;</span><br><span class="line">                 length: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">        <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">        globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指那些能够访问自由变量的函数（MDN）、闭包是指有权访问另外一个函数作用域中的变量的函数（红宝书p178）、《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> scope;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这里直接给出简要的执行过程：</p>
<ul>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ul>
<p>了解到这个过程，我们应该思考一个问题，那就是:</p>
<p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p>
<p>我们知道 f 执行上下文维护了一个作用域链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">     Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call和apply的模拟实现"><a href="#call和apply的模拟实现" class="headerlink" title="call和apply的模拟实现"></a><strong>call和apply的模拟实现</strong></h2><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> args = [];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">         args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">     context.fn = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> result;</span><br><span class="line">     <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">         result = context.fn();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> args = [];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">             args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">delete</span> context.fn</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.age = age;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">this</span>.habit = <span class="string">'Games'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"> Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayYourName())<span class="comment">//I am Kevin</span></span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乞丐版：完整版很深</span></span><br><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addCurry() <span class="comment">// 3//或者var addCurry = curry(add, 1);addCurry(2) // 3//或者var addCurry = curry(add);addCurry(1, 2) // 3</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length,width</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.l = length</span><br><span class="line">    <span class="keyword">this</span>.w = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.l*<span class="keyword">this</span>.w</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>)</span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>,length,length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype,&#123;</span><br><span class="line">     <span class="keyword">constructor</span>:&#123;</span><br><span class="line">     	value:Square</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">// 相当于Rectangle.prototype.constructor = Square</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)</span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="/2020/04/28/bind/1.jpg">

<p>爸爸的父亲等于妈妈的老公？？？</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><img src="/2020/04/28/bind/2.jpg">

<p>bind()创建的function上没有prototype/箭头函数上也没有prototype</p>
<img src="/2020/04/28/bind/5.jpg">



</div></div><a class="button-hover more" href="/2020/04/28/bind/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/04/28/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81-0/">Js防抖与节流</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div><div class="post-content"><div class="main-content content"><h1 id="JS防抖和节流"><a href="#JS防抖和节流" class="headerlink" title="JS防抖和节流"></a>JS防抖和节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>事件响应函数在一段时间后才执行，如果在这段时间内再次调用，则重新计算执行时间；当预定的时间内没有再次调用该函数，则执行响应逻辑</p>
<p><a href="http://www.underscore-js.com/functionsRelated.html" target="_blank" rel="noopener">underscore</a>中的debounce函数可以防抖</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>scroll事件滚动触发的时候</li>
<li>搜索框输入查询的时候</li>
<li>表单验证</li>
<li>按钮的提交事件</li>
<li>浏览器的窗口缩放，resize事件</li>
</ol>
<h3 id="自定义防抖函数"><a href="#自定义防抖函数" class="headerlink" title="自定义防抖函数"></a>自定义防抖函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数的自定义实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 等待的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate 是否立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result -- 返回值</span></span><br><span class="line">  <span class="keyword">let</span> timeout, result;</span><br><span class="line">  <span class="keyword">let</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span>(timeout) clearTimeout(timeout)</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// callNow是立即执行的变量</span></span><br><span class="line">      <span class="keyword">let</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="comment">// 由于最开始timeout为undefined,取反为true,故立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(self, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不会立即执行</span></span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//解决执行函数内部this指向问题以及event指向问题</span></span><br><span class="line">        result = func.apply(self, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消</span></span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = <span class="literal">null</span> <span class="comment">// 防止内存泄露</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>如果你持续的触发事件，每隔一段时间，只执行一次事件</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>DOM元素的拖拽功能的实现</li>
<li>计算鼠标移动的距离</li>
<li>监听scroll滚动事件</li>
</ol>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 -- 初步实现 -- 第一次会触发，最后一次不会触发</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 等待的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args</span><br><span class="line">  <span class="comment">// 之前的时间戳</span></span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 默认为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (now-old &gt; wait) &#123;</span><br><span class="line">      <span class="comment">// 立即执行</span></span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 -- 第一次不会触发，最后一次会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再次改进版本"><a href="#再次改进版本" class="headerlink" title="再次改进版本"></a>再次改进版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * 第一次会触发，最后一次会触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout</span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    old = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">    func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (now - old &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span> </span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * 最终版本</span></span><br><span class="line"><span class="comment"> * 第一次不会触发，最后一次会调用 leading:false, trailing:true</span></span><br><span class="line"><span class="comment"> * 第一次会触发，最后一次不会触发 leading:true, trailing:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trottle</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args, timeout, result</span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span> <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125; </span><br><span class="line">  <span class="keyword">let</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    old = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">    result = func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> trottled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">    <span class="keyword">if</span> (options.leading === <span class="literal">false</span>  &amp;&amp; !old) &#123;</span><br><span class="line">      old = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now - old &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span> </span><br><span class="line">      &#125;</span><br><span class="line">      result = func.apply(context, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  trottled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> trottled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2020/04/28/JS%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81-0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/03/28/deepCopy/">JS深拷贝</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div><div class="post-content"><div class="main-content content"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>创建了一个新的对象，这个对象有着原始对象属性值得精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a === source.a <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="判断类型的方式"><a href="#判断类型的方式" class="headerlink" title="判断类型的方式"></a>判断类型的方式</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof可以用于判断以下js的8种类型：</p>
<p>js的8中数据类型：</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li><strong>BigInt – 浏览器已经支持了</strong></li>
<li>String</li>
<li>Symbol</li>
<li>Object</li>
</ul>
<p>但也有缺点 — <strong>暂时性死区</strong>(TDZ)</p>
<p>我们知道let和const 具有暂时性死区(即在代码块内，使用let/const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”)</p>
<p>typeof也具有暂时性死区</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError -- 声明在后导致出错</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"  -- 若一个变量根本没有声明，倒不会报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考烂了的面试题</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>原理： 右边变量的prototype在左边变量的原型链上即可(右边构造函数的原型在不在左边实例的原型链上)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/mefelixwang/p/7525220.html" target="_blank" rel="noopener">JS原型链神图</a></p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>将一个对象从内存中完整的拷贝出来一份，从内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象</p>
<h3 id="最常用的一种方式-–-业务中用-不适合于面试"><a href="#最常用的一种方式-–-业务中用-不适合于面试" class="headerlink" title="最常用的一种方式 – 业务中用(不适合于面试)"></a>最常用的一种方式 – 业务中用(不适合于面试)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(x)) <span class="comment">// 将x深拷贝给d</span></span><br></pre></td></tr></table></figure>

<h3 id="基本版本"><a href="#基本版本" class="headerlink" title="基本版本"></a>基本版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> newArr = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">                newArr.push(obj[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> newObj = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                newObj[key] = <span class="keyword">this</span>.deepCopy(obj[key])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试版本"><a href="#面试版本" class="headerlink" title="面试版本"></a>面试版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试版本</span></span><br><span class="line"><span class="comment">// 判断是不是一个复杂类型</span></span><br><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; 				(obj !== <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="keyword">function</span> (<span class="params">obj, hash= new WeakMap(</span>)) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">     <span class="keyword">let</span> type = [<span class="built_in">Date</span>, <span class="built_in">RegExp</span>, <span class="built_in">Set</span>, <span class="built_in">Map</span>, <span class="built_in">WeakMap</span>, <span class="built_in">WeakSet</span>];</span><br><span class="line">     <span class="keyword">if</span> (type.includes(obj.constructor)) <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">     <span class="comment">// 如果成环了，参数obj = obj.loop = 最初的obj 会在WeakMap中找到第一次放入的obj提前返回第一次放入		WeakMap的cloneObj</span></span><br><span class="line">     <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj) <span class="comment">// 遍历传入参数所有键的特性</span></span><br><span class="line">     <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDesc) <span class="comment">// 继承原型</span></span><br><span class="line">     hash.set(obj, cloneObj)</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123; <span class="comment">//Reflect.ownKeys可以拷贝不可枚举属性和符号类型</span></span><br><span class="line">     <span class="comment">// 如果值是引用类型则递归调用deepClone</span></span><br><span class="line">     cloneObj[key] = </span><br><span class="line">          (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? 							deepCopy(obj[key], hash) : obj[key];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    bigInt: BigInt(<span class="number">12312</span>),</span><br><span class="line">    <span class="keyword">set</span>: new Set([2]),</span><br><span class="line">    map: new Map([['a', 222], ['b', 33]]),</span><br><span class="line">    num: 0,</span><br><span class="line">    str: '',</span><br><span class="line">    boolean: true,</span><br><span class="line">    unf: undefined,</span><br><span class="line">    nul: null,</span><br><span class="line">    obj: &#123;</span><br><span class="line">        name: <span class="string">'我是一个对象'</span>,</span><br><span class="line">        id: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是一个函数'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>),</span><br><span class="line">    reg: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'/我是一个正则/ig'</span>),</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'1'</span>)] : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'innumerable'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'不可枚举属性'</span></span><br><span class="line">&#125;)</span><br><span class="line">obj = <span class="built_in">Object</span>.create(obj, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)) </span><br><span class="line">obj.loop = obj</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">let</span> cloneObj = deepCopy(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cloneObj'</span>, cloneObj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(cloneObj)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> cloneObj[key] === <span class="string">'object'</span> || <span class="keyword">typeof</span> cloneObj[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>相同吗?`</span>, cloneObj[key] === obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习自京程一灯董老师课程，如有侵权，联系删除</p>
</blockquote>
</div></div><a class="button-hover more" href="/2020/03/28/deepCopy/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/12/06/CSSshuyu/">CSS专业术语</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-12-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B/">《CSS世界》</a></div></div><div class="post-content"><div class="main-content content"><h2 id="CSS常用专业术语"><a href="#CSS常用专业术语" class="headerlink" title="CSS常用专业术语"></a>CSS常用专业术语</h2><ol>
<li><p>属性：属性对应的是平常我们书面或交谈时对应的CSS中文称谓，例如height，color等</p>
</li>
<li><p>值：</p>
<ul>
<li>整数值</li>
<li>数值：如line-height:1.5中的1.5</li>
<li>百分比值</li>
<li>长度值：例如99px</li>
<li>颜色值：例如#99</li>
<li>字符串值等等</li>
</ul>
</li>
<li><p>关键字：如soild,inherit等</p>
</li>
<li><p>泛关键字：可以理解为公交车关键字，就是“所有CSS属性都可以使用的关键字”的意思。</p>
</li>
<li><p>变量：如CSS3中的currentColor等</p>
</li>
<li><p>长度单位：如px,em等(值 + 长度单位 = 长度)</p>
<ul>
<li><p>相对长度单位：</p>
<ul>
<li>相对字体长度单位<ul>
<li>em:其相对于当前对象内文本的font-size（如果当前对象内文本的font-size计量单位也是em，则当前对象内文本的font-size的参考对象为父元素文本font-size）。使用em可以较好的相应设备屏幕尺寸的变化，但是在进行元素设置时都需要知道父元素文本的font-size及当前对象内文本的font-size，如有遗漏可能会导致错误.</li>
<li>ex:字符x高度的一半，一般是字体高度一半。</li>
<li>rem:使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</li>
</ul>
</li>
<li>相对视区长度单位:vh,vw,vmin,vmax等<ul>
<li>视区所指为浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小)</li>
<li>vh:相对于视框的高度：视框高度是100vh</li>
<li>vw:相对于视框的宽度，视框宽度为100vw</li>
<li>vmin:相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">8</span>vm;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">8vmin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果视口的宽度是300mm，高度是200mm，那么上述代码中h1元素的字号将为16mm，即(8x200)/100，因为高度比宽度要小，所以计算的时候相对于高度。*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对长度单位：</p>
<ul>
<li>px:像素</li>
<li>cm</li>
<li>mm</li>
<li>pc : 皮卡Picas (1 皮卡 = 12 点)</li>
<li>pt : 点Points (1点 = 1/72英寸)</li>
</ul>
</li>
</ul>
</li>
<li><p>功能符:值以函数的形式指定起来的，主要用来表示颜色(rgba和hsla),背景图片地址(url),计算(calc)等，如rfb(0,0,0,.5)、url(‘css-World.png’)等</p>
</li>
<li><p>属性值：属性冒号后面的所有内容</p>
</li>
<li><p>声明：属性名加上属性值就是声明</p>
</li>
<li><p>声明块：用花括号{}包裹的一系列声明</p>
</li>
<li><p>规则或者规则集：出现了选择器，并且后面还跟着声明块</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.vo</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">99px</span>;</span><br><span class="line">    <span class="attribute">color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>选择器:</p>
</li>
<li><p>关系选择器</p>
</li>
<li><p>@规则:指的是以@字符开始的一些规则。</p>
</li>
</ol>
</div></div><a class="button-hover more" href="/2019/12/06/CSSshuyu/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/12/06/CSSWorld1/">流、元素与基本尺寸(1)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-12-06</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B/">《CSS世界》</a></div></div><div class="post-content"><div class="main-content content"><h2 id="流、元素与基本尺寸"><a href="#流、元素与基本尺寸" class="headerlink" title="流、元素与基本尺寸"></a>流、元素与基本尺寸</h2><ol>
<li>流：实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的一套物理规则，流跟现实世界的水流有异曲同工之妙</li>
<li>CSS中的标签种类繁多，但通常我们把他们分为两类：块级元素(block-level element)和内联元素(inline element)  <h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4></li>
<li>常见的块级元素有div,li,table等，但需要注意的是块级元素和display属性值为block的元素是不一样的，例如li元素默认display值时list-item,table元素默认的display值是table，但他们均是块级元素(块级元素的基本特征：一个水平流上只显示一个元素，多个块级元素换行显示)。</li>
<li>由于块级元素具有换行的特性，因此理论上它可以配合clear属性来清除浮动带来的影响</li>
<li>浮动：元素脱离文档流，使元素在页面中水平排列<ul>
<li>float可选值如下：<ul>
<li>none默认值，元素默认在文档流中排列</li>
<li>left:元素立即脱离文档流，向页面左侧浮动</li>
<li>right:元素立即脱离文档流，向页面右侧浮动</li>
</ul>
</li>
<li>内联元素脱离文档流后会变成块元素</li>
<li>块元素脱离文档流后高度和宽度会被内容撑开</li>
<li>浮动的元素不会盖住文字，文字会自动环绕在浮动元素周围，所以我们可以通过浮动来设置文字环绕图片的效果</li>
<li>如果浮动元素上边是一个没有浮动的元素，则浮动元素不会超过块元素，浮动的元素不会超过他上边的兄弟元素</li>
<li>当一个元素设置为浮动以后(非none值)，元素会立即脱离文档流，脱离之后，它下面的元素会立即向上移动，元素浮动以后，会尽量向元素的左上或者是右上漂浮，直到遇到父元素的边框或者其他的浮动元素。</li>
</ul>
</li>
<li>消除浮动：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">clear</span>: both;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>小案例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;清除浮动&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        .box&#123;</span></span><br><span class="line"><span class="regexp">            padding: 10px;</span></span><br><span class="line"><span class="regexp">            background-color:#cd0000;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .box &gt; img &#123;</span></span><br><span class="line"><span class="regexp">            float:left;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .clear::after&#123;</span></span><br><span class="line"><span class="regexp">            content: "";</span></span><br><span class="line"><span class="regexp">            display: block;</span></span><br><span class="line"><span class="regexp">            clear: both;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="box clear"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img src="../img</span><span class="regexp">/1.jpg" alt="功夫熊猫"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</div></div><a class="button-hover more" href="/2019/12/06/CSSWorld1/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/11/16/githu/">GitHub使用技巧(一)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-11-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/GitHub/">GitHub</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Github%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/">Github使用小技巧</a></div></div><div class="post-content"><div class="main-content content"><h2 id="GitHub使用小技巧-一"><a href="#GitHub使用小技巧-一" class="headerlink" title="GitHub使用小技巧(一)"></a>GitHub使用小技巧(一)</h2><h3 id="在GitHub中搜索你所需要的知识得一些小窍门"><a href="#在GitHub中搜索你所需要的知识得一些小窍门" class="headerlink" title="在GitHub中搜索你所需要的知识得一些小窍门"></a>在GitHub中搜索你所需要的知识得一些小窍门</h3><p>   在日常的学习中，我们很多时间需要去从GitHub上寻找一些开源项目<br>   首先，我们需要了解GitHub上面开源项目的一些基本知识：项目名,项目源码，项目描述，Readme.md，star,fork数，更新日期等等</p>
<ol>
<li>in:name 搜索关键字   —-在GitHub项目名上精确搜索，如：in:name app开发，可找到所有项目名中包含“app开发”的项目</li>
<li>stars: 整数          —–GitHub项目的star数目，例如你要找star数目大于3000的项目，stars:&gt;3000</li>
<li>forks: 整数          ——GitHub项目fork数目，与star数目用法相同</li>
<li>in:readme 搜索关键字  ——-在Readme中搜索</li>
<li>in:discription 搜索关键字   ——在描述里面搜索你所需要的内容</li>
<li>language:语言名   —— 如需要搜索java项目；language:java即可</li>
<li>pushed: 日期    ——-根据日期进行搜索，例如搜索2019年11月2日以后更新的项目, pushed:&gt;2019-11-02</li>
<li>以上7点可以混合使用，以使你的搜索更加精确，找到你感兴趣的东西。</li>
</ol>
</div></div><a class="button-hover more" href="/2019/11/16/githu/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/11/09/sf3/">55-跳跃游戏</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-11-09</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/LeetCode%E7%AE%97%E6%B3%95/">LeetCode算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/">贪心策略</a></div></div><div class="post-content"><div class="main-content content"><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>题目：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>
<ol>
<li>解法一：<ul>
<li>解题思路：最容易想到的方法，直接遍历每一种可能的情况，暴力破解，但是这个方法超时(哭了)</li>
<li>代码如下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">canJumpyue</span>(<span class="params">position , nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//到达最后一个，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span>(position == nums.length<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> JumpLength = <span class="built_in">Math</span>.min(position+nums[position],nums.length<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//遍历所有的可能路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> nextposition = position + <span class="number">1</span>;nextposition &lt;= JumpLength;nextposition++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(canJumpyue(nextposition,nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpyue(<span class="number">0</span>,nums);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</div></div><a class="button-hover more" href="/2019/11/09/sf3/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/10/31/ub2/">ubuntu系统重装</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-10-31</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/ubuntu/">ubuntu</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/ubuntu/">ubuntu</a></div></div><div class="post-content"><div class="main-content content"><h2 id="ubuntu系统重装-链接如下"><a href="#ubuntu系统重装-链接如下" class="headerlink" title="ubuntu系统重装(链接如下)"></a>ubuntu系统重装(链接如下)</h2><p><a href="https://blog.csdn.net/tjuyanming/article/details/64929901" target="_blank" rel="noopener">UEFI启动Windows10+Ubuntu双系统删除Ubuntu方法</a><br><a href="https://www.jianshu.com/p/0726b0cbed0e" target="_blank" rel="noopener">安装win10+ubuntu18.04双系统</a><br><a href="https://www.jianshu.com/p/66a092caaa36" target="_blank" rel="noopener">在Win10与Ubuntu双系统中删除Ubuntu</a></p>
<blockquote>
<p>如有侵权，请联系删除</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/10/31/ub2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/10/24/stringMatch/">44--通配符匹配</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-10-26</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/LeetCode%E7%AE%97%E6%B3%95/">LeetCode算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/">贪心策略</a></div></div><div class="post-content"><div class="main-content content"><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><ol>
<li><p>问题描述<br>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘ ? ‘ 和 ‘ * ‘ 的通配符匹配。<br>‘ ? ‘ 可以匹配任何单个字符。<br>‘ * ‘ 可以匹配任意字符串（包括空字符串）<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符  ?  和  *</p>
</li>
<li><p>代码实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star=<span class="number">-1</span>, match=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sp=<span class="number">0</span>, pp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sp &lt; s.length)&#123;</span><br><span class="line">     <span class="keyword">if</span>(pp&lt;p.length &amp;&amp; (s[sp] == p[pp] || p[pp] ==<span class="string">"?"</span>))&#123;</span><br><span class="line">           sp++;</span><br><span class="line">           pp++;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pp&lt;p.length &amp;&amp; p[pp] == <span class="string">"*"</span>)&#123;</span><br><span class="line">           star = pp;</span><br><span class="line">           match = sp;</span><br><span class="line">           pp++;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(star != <span class="number">-1</span>)&#123;</span><br><span class="line">           pp = star + <span class="number">1</span>;</span><br><span class="line">           match++;</span><br><span class="line">           sp = match;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span> (pp &lt; p.length &amp;&amp; p[pp] == <span class="string">'*'</span>) pp++;</span><br><span class="line">    <span class="keyword">return</span> pp == p.length;</span><br></pre></td></tr></table></figure></li>
</ol>
</div></div><a class="button-hover more" href="/2019/10/24/stringMatch/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2023 By lg</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>